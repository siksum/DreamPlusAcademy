
Filename: 0x026195ce819f1cb4fa872ce306b14b91ab16a3ab_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In YAMSilver.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 15000 * decimalFactor
 In YAMSilver.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
SafeMath.slitherConstructorConstantVariables() (0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a_integerOverflow.sol#4-43) uses literals with too many digits: 256 recommended suffix: ether
	- MAX_UINT = 2 ** 256 - 1 (0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a_integerOverflow.sol#6)
 VESTELLAToken.slitherConstructorConstantVariables() (0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a_integerOverflow.sol#363-506) uses literals with too many digits: 15000000000 recommended suffix: gwei
	- _INIT_TOTALSUPPLY = 15000000000 (0x03452e69ffcd9c45ca34ff4d9ba2209d38a8d56a_integerOverflow.sol#369)
 check: over-underflow
impact: Low
confidence: Low
description
In VESTELLAToken.transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balances[msg.sender].sub(_value) >= getLockedAmount(msg.sender))
 In SafeMath.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_UINT = 2 ** 256 - 1
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In VESTELLAToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In VESTELLAToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balances[account].sub(value) >= getLockedAmount(account))
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In VESTELLAToken.burn, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balances[msg.sender].sub(value) >= getLockedAmount(msg.sender))
 In VESTELLAToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In VESTELLAToken.addLockPosition, it can be over/underflowed. check your logic: EXPRESSION locktime[account].push(time[i])
 In VESTELLAToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION super.burnFrom(account,value)
 In VESTELLAToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balances[_from].sub(_value) >= getLockedAmount(_from))
 In VESTELLAToken.addLockPosition, it can be over/underflowed. check your logic: EXPRESSION lockamount[account].push(_amount)
 In VESTELLAToken.addLockPosition, it can be over/underflowed. check your logic: NEW VARIABLE _amount = amount[i] * 10 ** uint256(decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: RETURN _a + _b
 In VESTELLAToken.getLockedAmount, it can be over/underflowed. check your logic: EXPRESSION i ++
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In VESTELLAToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In VESTELLAToken.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply_ = _INIT_TOTALSUPPLY * 10 ** uint256(decimals)
 In VESTELLAToken.burn, it can be over/underflowed. check your logic: EXPRESSION super.burn(value)
 In VESTELLAToken.airdrop, it can be over/underflowed. check your logic: EXPRESSION _batchTransfer(_to,_amount)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: RETURN _a * _b
 In VESTELLAToken.addLockPosition, it can be over/underflowed. check your logic: EXPRESSION i ++
 In VESTELLAToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In VESTELLAToken._batchTransfer, it can be over/underflowed. check your logic: EXPRESSION i += 1
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN _a - _b
 
line_number: 184
line_number: 219
line_number: 237
line_number: 258
line_number: 276
line_number: 292

Filename: 0x034f8165470b0a26b8daac1c3cd1cc6156e8294d_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In EracoinToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _totalSupply -= _value
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In EracoinToken.burn, it can be over/underflowed. check your logic: EXPRESSION balances[msg.sender] -= _value
 In EracoinToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balances[_from] -= _value
 In EracoinToken.mint, it can be over/underflowed. check your logic: EXPRESSION _totalSupply += _value
 In EracoinToken.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 300000000 * 10 ** uint256(decimals)
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In EracoinToken.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_totalSupply + _value >= _totalSupply)
 In EracoinToken.burn, it can be over/underflowed. check your logic: EXPRESSION _totalSupply -= _value
 In EracoinToken.mint, it can be over/underflowed. check your logic: EXPRESSION balances[_recipient] += _value
 In EracoinToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowed[_from][msg.sender] -= _value
 
line_number: 155
line_number: 157
line_number: 189
line_number: 191
line_number: 193

Filename: 0x0452dd090288a5197cb4c375611b70bcfa5eb18c_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
ANASH.slitherConstructorConstantVariables() (0x0452dd090288a5197cb4c375611b70bcfa5eb18c_integerOverflow.sol#210-249) uses literals with too many digits: 20000000000 recommended suffix: gwei
	- premined = 20000000000 (0x0452dd090288a5197cb4c375611b70bcfa5eb18c_integerOverflow.sol#214)
 check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In ANASH.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In TokenStandard.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenBasic.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In ANASH.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In TokenStandard.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 
line_number: 112
line_number: 120
line_number: 163
line_number: 171
line_number: 193
line_number: 203

Filename: 0x0785d6edc7c7a19cbcc5fb56a406b1351fc907dc_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In TimeLockToken.timelockAccount, it can be over/underflowed. check your logic: EXPRESSION r_time = now + (releasetime * 86400)
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In TimeLockToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In GoldToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In GoldToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GoldToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In FreezableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In GoldToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In GoldToken.timelockAccount, it can be over/underflowed. check your logic: EXPRESSION r_time = now + (releasetime * 86400)
 In FreezableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In GoldToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = 500000000 * (10 ** decimals)
 In TimeLockToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 
line_number: 77
line_number: 97
line_number: 99
line_number: 123
line_number: 141
line_number: 152

Filename: 0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2040-2079) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(staker.amount <= 0x100000000000000000000000000000000,staking amount is too high) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2067)
 ContributionReward.validateProposalParams(int256,uint256[5]) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2978-2997) uses literals with too many digits: 255 recommended suffix: ether
	- require(bool,string)(! (int256(_rewards[4]) == - 1 && _reputationChange == (- 2 ** 255)),numberOfPeriods * _reputationChange will overflow) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2982-2983)
 GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2040-2079) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(proposal.totalStakes <= uint256(0x100000000000000000000000000000000).sub(proposal.daoBountyRemain),total stakes is too high) (0x08cc7bba91b849156e9c44ded51896b38400f55b_integerOverflow.sol#2068-2069)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply - amountBurned)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In ERC20Burnable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In DAOToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceFrom = balanceOf(_user)
 In ContributionReward.redeemExternalToken, it can be over/underflowed. check your logic: NEW VARIABLE periodsToPay = getPeriodsToPay(_proposalId,address(_avatar),3)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In ERC20Burnable.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In GenesisProtocolLogic.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION realResult = mul(realResult,tempRealBase)
 In GenesisProtocol.vote, it can be over/underflowed. check your logic: RETURN internalVote(_proposalId,voter,_vote,_amount)
 In ContributionReward.redeemReputation, it can be over/underflowed. check your logic: EXPRESSION require(bool)(ControllerInterface(_avatar.owner()).burnReputation(uint256(reputation * (- 1)),_proposal.beneficiary,address(_avatar)))
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In GenesisProtocol.redeem, it can be over/underflowed. check your logic: NEW VARIABLE totalStakesLeftAfterCallBounty = proposal.stakes[NO].add(proposal.stakes[YES]).sub(calcExecuteCallBounty(_proposalId))
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In ContributionReward.redeemEther, it can be over/underflowed. check your logic: NEW VARIABLE periodsToPay = getPeriodsToPay(_proposalId,address(_avatar),2)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(curTotalSupply + _amount >= curTotalSupply)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE mid = (max + min + 1) / 2
 In ContributionReward.redeem, it can be over/underflowed. check your logic: EXPRESSION etherReward = redeemEther(_proposalId,_avatar)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: IF (checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In Reputation.totalSupply, it can be over/underflowed. check your logic: RETURN totalSupplyAt(block.number)
 In GenesisProtocol.score, it can be over/underflowed. check your logic: RETURN _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In ContributionReward.validateProposalParams, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((int256(_rewards[4]) * _reputationChange) / int256(_rewards[4]) == _reputationChange,numberOfPeriods * reputationChange will overflow)
 In Reputation.balanceOf, it can be over/underflowed. check your logic: RETURN balanceOfAt(_owner,block.number)
 In DAOToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GenesisProtocolLogic.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In ContributionReward.redeemReputation, it can be over/underflowed. check your logic: EXPRESSION reputation = int256(periodsToPay) * _proposal.reputationChange
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE oldCheckPoint = checkpoints[checkpoints.length - 1]
 In RealMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE res = realA * realB
 In GenesisProtocol.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceTo = balanceOf(_user)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: IF _block >= checkpoints[checkpoints.length - 1].fromBlock
 In GenesisProtocol.execute, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION tempRealBase = mul(tempRealBase,tempRealBase)
 In GenesisProtocol.stakeWithSignature, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,staker)
 In ContributionReward.redeem, it can be over/underflowed. check your logic: EXPRESSION reputationReward = redeemReputation(_proposalId,_avatar)
 In ECDSA.recover, it can be over/underflowed. check your logic: EXPRESSION v += 27
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In GenesisProtocol.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION expirationCallBounty = calcExecuteCallBounty(_proposalId)
 In Reputation.totalSupplyAt, it can be over/underflowed. check your logic: RETURN getValueAt(totalSupplyHistory,_blockNumber)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.balanceOfAt, it can be over/underflowed. check your logic: RETURN getValueAt(balances[_owner],_blockNumber)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(previousBalanceTo + _amount >= previousBalanceTo)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: RETURN checkpoints[checkpoints.length - 1].value
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceTo + _amount)
 In GenesisProtocol.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE max = checkpoints.length - 1
 In Reputation.getValueAt, it can be over/underflowed. check your logic: EXPRESSION max = mid - 1
 In ContributionReward.validateProposalParams, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((_rewards[4] * _rewards[0]) / _rewards[4] == _rewards[0],numberOfPeriods * tokenReward will overflow)
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In ContributionReward.redeem, it can be over/underflowed. check your logic: EXPRESSION externalTokenReward = redeemExternalToken(_proposalId,_avatar)
 In DAOToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In ERC20Burnable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In GenesisProtocolLogic.redeem, it can be over/underflowed. check your logic: NEW VARIABLE totalStakesLeftAfterCallBounty = proposal.stakes[NO].add(proposal.stakes[YES]).sub(calcExecuteCallBounty(_proposalId))
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In RealMath.fraction, it can be over/underflowed. check your logic: RETURN div(uint256(numerator) * REAL_ONE,uint256(denominator) * REAL_ONE)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In ContributionReward.redeem, it can be over/underflowed. check your logic: EXPRESSION nativeTokenReward = redeemNativeToken(_proposalId,_avatar)
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In GenesisProtocol.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In ERC20Burnable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Burnable.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In ContributionReward.validateProposalParams, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(! (int256(_rewards[4]) == - 1 && _reputationChange == (- 2 ** 255)),numberOfPeriods * _reputationChange will overflow)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In DAOToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ContributionReward.redeemReputation, it can be over/underflowed. check your logic: NEW VARIABLE periodsToPay = getPeriodsToPay(_proposalId,address(_avatar),0)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE newCheckPoint = checkpoints[checkpoints.length ++]
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In DAOToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(_to,_amount)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocol.stake, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,msg.sender)
 In GenesisProtocol.calcExecuteCallBounty, it can be over/underflowed. check your logic: RETURN rewardSeconds.mul(proposals[_proposalId].stakes[YES]).div(maxRewardSeconds * 10)
 In ContributionReward.proposeContributionReward, it can be over/underflowed. check your logic: EXPRESSION validateProposalParams(_reputationChange,_rewards)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In DAOToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceFrom - amountBurned)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In GenesisProtocolLogic.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION expirationCallBounty = calcExecuteCallBounty(_proposalId)
 In RealMath.div, it can be over/underflowed. check your logic: RETURN uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator))
 In ContributionReward.redeemNativeToken, it can be over/underflowed. check your logic: NEW VARIABLE periodsToPay = getPeriodsToPay(_proposalId,address(_avatar),1)
 In GenesisProtocolLogic.calcExecuteCallBounty, it can be over/underflowed. check your logic: RETURN rewardSeconds.mul(proposals[_proposalId].stakes[YES]).div(maxRewardSeconds * 10)
 In ContributionReward.validateProposalParams, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((_rewards[4] * _rewards[1]) / _rewards[4] == _rewards[1],numberOfPeriods * ethReward will overflow)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In ContributionReward.validateProposalParams, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((_rewards[4] * _rewards[2]) / _rewards[4] == _rewards[2],numberOfPeriods * texternalTokenReward will overflow)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 
line_number: 543
line_number: 563
line_number: 582
line_number: 1640
line_number: 1827

Filename: 0x0a6460ee3a05ea700e77d63dbb19528fbaab0d4f_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In TokenController.addOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In multiowned.removeOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In multiowned.getOwners, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TokenController.addPauser, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In MintableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In multiowned.addOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In HlorToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,value)
 In multiowned.reorganizeOwners, it can be over/underflowed. check your logic: EXPRESSION free ++
 In TokenController.addMinter, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In TokenController.makeOwnerBitmapBit, it can be over/underflowed. check your logic: RETURN 2 ** ownerIndex
 In PausableToken.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In TokenController.finishMinting, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In multiowned.addOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In multiowned.getOwner, it can be over/underflowed. check your logic: RETURN m_owners[ownerIndex + 1]
 In TokenController.clearPending, it can be over/underflowed. check your logic: EXPRESSION ++ i
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In multiowned.revoke, it can be over/underflowed. check your logic: EXPRESSION pending.ownersDone -= ownerIndexBit
 In multiowned.changeOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In MintableToken.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In multiowned.removeOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In TokenController.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.yetNeeded --
 In TokenController.constructor, it can be over/underflowed. check your logic: NEW VARIABLE currentOwnerIndex = checkOwnerIndex(i + 1)
 In TokenController.addOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In HlorToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In TokenController.getOwner, it can be over/underflowed. check your logic: RETURN m_owners[ownerIndex + 1]
 In TokenController.addOwner, it can be over/underflowed. check your logic: EXPRESSION m_numOwners ++
 In Pausable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In TokenController.reorganizeOwners, it can be over/underflowed. check your logic: EXPRESSION m_numOwners --
 In MintableToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In multiowned.revoke, it can be over/underflowed. check your logic: EXPRESSION pending.yetNeeded ++
 In multiowned.constructor, it can be over/underflowed. check your logic: EXPRESSION ++ i
 In HlorToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In TokenController.removeOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In TokenController.removeOwner, it can be over/underflowed. check your logic: EXPRESSION validNumOwners(m_numOwners - 1)
 In TokenController.addOwner, it can be over/underflowed. check your logic: EXPRESSION validNumOwners(m_numOwners + 1)
 In multiowned.getOwners, it can be over/underflowed. check your logic: EXPRESSION result[i] = getOwner(i)
 In TokenController.getOwners, it can be over/underflowed. check your logic: EXPRESSION result[i] = getOwner(i)
 In TokenController.removeOwner, it can be over/underflowed. check your logic: EXPRESSION reorganizeOwners()
 In multiowned.removeOwner, it can be over/underflowed. check your logic: EXPRESSION reorganizeOwners()
 In multiowned.hasConfirmed, it can be over/underflowed. check your logic: RETURN ! (m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0)
 In multiowned.changeRequirement, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In HlorToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In multiowned.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.ownersDone |= ownerIndexBit
 In TokenController.reorganizeOwners, it can be over/underflowed. check your logic: EXPRESSION free ++
 In multiowned.revoke, it can be over/underflowed. check your logic: NEW VARIABLE ownerIndexBit = makeOwnerBitmapBit(msg.sender)
 In TokenController.changeOwner, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In HlorToken.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In multiowned.confirmAndCheck, it can be over/underflowed. check your logic: NEW VARIABLE ownerIndexBit = makeOwnerBitmapBit(msg.sender)
 In TokenController.revoke, it can be over/underflowed. check your logic: NEW VARIABLE ownerIndexBit = makeOwnerBitmapBit(msg.sender)
 In TokenController.constructor, it can be over/underflowed. check your logic: EXPRESSION ++ i
 In PausableToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In multiowned.removeOwner, it can be over/underflowed. check your logic: EXPRESSION multiOwnedValidRequirement(m_multiOwnedRequired,m_numOwners - 1)
 In multiowned.addOwner, it can be over/underflowed. check your logic: EXPRESSION m_numOwners ++
 In multiowned.changeRequirement, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In multiowned.makeOwnerBitmapBit, it can be over/underflowed. check your logic: RETURN 2 ** ownerIndex
 In TokenController.changeRequirement, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In TokenController.revoke, it can be over/underflowed. check your logic: EXPRESSION pending.yetNeeded ++
 In multiowned.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.yetNeeded --
 In multiowned.changeOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In multiowned.constructor, it can be over/underflowed. check your logic: NEW VARIABLE currentOwnerIndex = checkOwnerIndex(i + 1)
 In TokenController.getOwners, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TokenController.constructor, it can be over/underflowed. check your logic: EXPRESSION multiowned(_owners,_required)
 In TokenController.unpause, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In multiowned.addOwner, it can be over/underflowed. check your logic: EXPRESSION validNumOwners(m_numOwners + 1)
 In TokenController.confirmAndCheck, it can be over/underflowed. check your logic: NEW VARIABLE ownerIndexBit = makeOwnerBitmapBit(msg.sender)
 In MintableToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,value)
 In TokenController.removeOwner, it can be over/underflowed. check your logic: EXPRESSION multiOwnedValidRequirement(m_multiOwnedRequired,m_numOwners - 1)
 In Pausable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In HlorToken.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In multiowned.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.index = m_multiOwnedPendingIndex.length ++
 In multiowned.reorganizeOwners, it can be over/underflowed. check your logic: EXPRESSION m_numOwners --
 In TokenController.pause, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In multiowned.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In TokenController.changeOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In multiowned.clearPending, it can be over/underflowed. check your logic: EXPRESSION ++ i
 In multiowned.removeOwner, it can be over/underflowed. check your logic: EXPRESSION validNumOwners(m_numOwners - 1)
 In TokenController.revoke, it can be over/underflowed. check your logic: EXPRESSION pending.ownersDone -= ownerIndexBit
 In MintableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In TokenController.changeRequirement, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In TokenController.removeOwner, it can be over/underflowed. check your logic: EXPRESSION onlymanyowners(keccak256(bytes)(msg.data))
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In TokenController.hasConfirmed, it can be over/underflowed. check your logic: RETURN ! (m_multiOwnedPending[_operation].ownersDone & makeOwnerBitmapBit(_owner) == 0)
 In HlorToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In MintableToken.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In PausableToken.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In TokenController.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION clearPending()
 In MintableToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In TokenController.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.ownersDone |= ownerIndexBit
 In TokenController.confirmAndCheck, it can be over/underflowed. check your logic: EXPRESSION pending.index = m_multiOwnedPendingIndex.length ++
 
line_number: 215
line_number: 235
line_number: 254

Filename: 0x0a9308e51504365675fbfaa59f236bdf20497d5c_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Jamiecoin.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = 1000000 * (10 ** decimals)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 83
line_number: 85
line_number: 108
line_number: 121

Filename: 0x0f1cf425dd760f2ce2ba369cf30b3cb93de54668_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
NewToken.slitherConstructorConstantVariables() (0x0f1cf425dd760f2ce2ba369cf30b3cb93de54668_integerOverflow.sol#242-260) uses literals with too many digits: 1000000000 recommended suffix: gwei
	- initialSupply = 1000000000 (0x0f1cf425dd760f2ce2ba369cf30b3cb93de54668_integerOverflow.sol#248)
 NewToken.slitherConstructorConstantVariables() (0x0f1cf425dd760f2ce2ba369cf30b3cb93de54668_integerOverflow.sol#242-260) uses literals with too many digits: 256 recommended suffix: ether
	- MAX_UINT = 2 ** 256 - 1 (0x0f1cf425dd760f2ce2ba369cf30b3cb93de54668_integerOverflow.sol#153)
 check: over-underflow
impact: Low
confidence: Low
description
In NewToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_UINT = 2 ** 256 - 1
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In StandardToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_UINT = 2 ** 256 - 1
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In NewToken.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply_ = initialSupply * 10 ** uint256(decimals)
 
line_number: 121
line_number: 168
line_number: 214
line_number: 234

Filename: 0x0f736ec150749f8064fc96626eb36607ebad97e2_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x0f736ec150749f8064fc96626eb36607ebad97e2_integerOverflow.sol#2039-2077) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(staker.amount <= 0x100000000000000000000000000000000,staking amount is too high) (0x0f736ec150749f8064fc96626eb36607ebad97e2_integerOverflow.sol#2066)
 GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x0f736ec150749f8064fc96626eb36607ebad97e2_integerOverflow.sol#2039-2077) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(proposal.totalStakes <= 0x100000000000000000000000000000000,total stakes is too high) (0x0f736ec150749f8064fc96626eb36607ebad97e2_integerOverflow.sol#2067)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply - amountBurned)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In ERC20Burnable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In DAOToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceFrom = balanceOf(_user)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In ERC20Burnable.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In GenesisProtocolLogic.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION realResult = mul(realResult,tempRealBase)
 In GenesisProtocol.vote, it can be over/underflowed. check your logic: RETURN internalVote(_proposalId,voter,_vote,_amount)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(curTotalSupply + _amount >= curTotalSupply)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE mid = (max + min + 1) / 2
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: IF (checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In Reputation.totalSupply, it can be over/underflowed. check your logic: RETURN totalSupplyAt(block.number)
 In GenesisProtocol.score, it can be over/underflowed. check your logic: RETURN _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.balanceOf, it can be over/underflowed. check your logic: RETURN balanceOfAt(_owner,block.number)
 In DAOToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GenesisProtocolLogic.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE oldCheckPoint = checkpoints[checkpoints.length - 1]
 In RealMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE res = realA * realB
 In GenesisProtocol.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceTo = balanceOf(_user)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: IF _block >= checkpoints[checkpoints.length - 1].fromBlock
 In GenesisProtocol.execute, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION tempRealBase = mul(tempRealBase,tempRealBase)
 In GenesisProtocol.stakeWithSignature, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,staker)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.totalSupplyAt, it can be over/underflowed. check your logic: RETURN getValueAt(totalSupplyHistory,_blockNumber)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.balanceOfAt, it can be over/underflowed. check your logic: RETURN getValueAt(balances[_owner],_blockNumber)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(previousBalanceTo + _amount >= previousBalanceTo)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: RETURN checkpoints[checkpoints.length - 1].value
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceTo + _amount)
 In GenesisProtocol.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE max = checkpoints.length - 1
 In Reputation.getValueAt, it can be over/underflowed. check your logic: EXPRESSION max = mid - 1
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In DAOToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In ERC20Burnable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In RealMath.fraction, it can be over/underflowed. check your logic: RETURN div(uint256(numerator) * REAL_ONE,uint256(denominator) * REAL_ONE)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In GenesisProtocol.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In ERC20Burnable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Burnable.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In DAOToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE newCheckPoint = checkpoints[checkpoints.length ++]
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In DAOToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(_to,_amount)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocol.stake, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,msg.sender)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In DAOToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceFrom - amountBurned)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In RealMath.div, it can be over/underflowed. check your logic: RETURN uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator))
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 
line_number: 1838

Filename: 0x133db2e37d8676e425eca72d3ffc3b97855d31d3_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
LeaxToken.slitherConstructorConstantVariables() (0x133db2e37d8676e425eca72d3ffc3b97855d31d3_integerOverflow.sol#269-289) uses literals with too many digits: 21000000000 recommended suffix: gwei
	- initial_supply = 21000000000 * (10 ** 18) (0x133db2e37d8676e425eca72d3ffc3b97855d31d3_integerOverflow.sol#274)
 LeaxToken.slitherConstructorConstantVariables() (0x133db2e37d8676e425eca72d3ffc3b97855d31d3_integerOverflow.sol#269-289) uses literals with too many digits: 18 recommended suffix: ether
	- initial_supply = 21000000000 * (10 ** 18) (0x133db2e37d8676e425eca72d3ffc3b97855d31d3_integerOverflow.sol#274)
 check: over-underflow
impact: Low
confidence: Low
description
In LeaxToken.burn, it can be over/underflowed. check your logic: EXPRESSION burnTokens(msg.sender,amount)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In LeaxToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT initial_supply = 21000000000 * (10 ** 18)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In LeaxToken.constructor, it can be over/underflowed. check your logic: EXPRESSION mintInternal(initial_holder,initial_supply)
 
line_number: 137
line_number: 139
line_number: 167
line_number: 169
line_number: 171
line_number: 213
line_number: 231

Filename: 0x1b33d4ba1635442c484dcb9ce8c18d0f3d308e85_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
AOLibrary.slitherConstructorConstantVariables() (0x1b33d4ba1635442c484dcb9ce8c18d0f3d308e85_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _PERCENTAGE_DIVISOR = 10 ** 6 (0x1b33d4ba1635442c484dcb9ce8c18d0f3d308e85_integerOverflow.sol#344)
 AOLibrary.slitherConstructorConstantVariables() (0x1b33d4ba1635442c484dcb9ce8c18d0f3d308e85_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _MULTIPLIER_DIVISOR = 10 ** 6 (0x1b33d4ba1635442c484dcb9ce8c18d0f3d308e85_integerOverflow.sol#343)
 check: over-underflow
impact: Low
confidence: Low
description
In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _MULTIPLIER_DIVISOR = 10 ** 6
 In LogosZetta.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf[_to] + _value > balanceOf[_to])
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _PERCENTAGE_DIVISOR = 10 ** 6
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOLibrary.numDigits, it can be over/underflowed. check your logic: EXPRESSION digits ++
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_to] += _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In LogosZetta.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In TAOCurrency.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In AOLibrary.calculateNetworkBonusAmount, it can be over/underflowed. check your logic: NEW VARIABLE bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount,_totalPrimordialMintable,_totalPrimordialMinted,_startingMultiplier,_endingMultiplier)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: NEW VARIABLE previousBalances = balanceOf[_from] + balanceOf[_to]
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)
 In TAOCurrency.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 
line_number: 815

Filename: 0x1fd8dfd8ee9ce53b62c2d5bc944d5f40da5330c1_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In ERC20Pausable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In TRYCO.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In TRYCO.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ERC20Pausable.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In TRYCO.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In TRYCO._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In TRYCO.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In ERC20Pausable.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In TRYCO.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In TRYCO.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In TRYCO.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,totalSupply)
 
line_number: 182
line_number: 202
line_number: 221

Filename: 0x2121a1b68e9c2cc8ff4bfd8bcd0f891ece331c51_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
TokenERC20.constructor() (0x2121a1b68e9c2cc8ff4bfd8bcd0f891ece331c51_integerOverflow.sol#79-86) uses literals with too many digits: 12 recommended suffix: szabo
	- _totalSupply = 11 ** 12 * 12 ** uint256(decimals) (0x2121a1b68e9c2cc8ff4bfd8bcd0f891ece331c51_integerOverflow.sol#83)
 check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 11 ** 12 * 12 ** uint256(decimals)
 In TANTAN.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 11 ** 12 * 12 ** uint256(decimals)
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TANTAN.getAirdrop, it can be over/underflowed. check your logic: EXPRESSION aTot ++
 In TANTAN.tokenSale, it can be over/underflowed. check your logic: EXPRESSION sTot ++
 In TANTAN.tokenSale, it can be over/underflowed. check your logic: EXPRESSION _tkns = sChunk * _price
 
line_number: 95
line_number: 97
line_number: 108
line_number: 110
line_number: 112

Filename: 0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
CraftR.constructor() (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#163-174) uses literals with too many digits: 24 recommended suffix: ether
	- maxTotalSupply = 100 * 10 ** 24 (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#165)
 CraftR.slitherConstructorVariables() (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#117-345) uses literals with too many digits: 17 recommended suffix: finney
	- defaultPOS = 10 ** 17 (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#130)
 CraftR.constructor() (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#163-174) uses literals with too many digits: 24 recommended suffix: ether
	- totalInitialSupply = 60 * 10 ** 24 (0x2784dcd08f4b1bb25af84fd0b702e2aa5d5d1d64_integerOverflow.sol#166)
 check: over-underflow
impact: Low
confidence: Low
description
In CraftR.transfer, it can be over/underflowed. check your logic: EXPRESSION txIns[_to].push(transferInStruct(uint128(_value),_now))
 In CraftR.getPosReward, it can be over/underflowed. check your logic: NEW VARIABLE _coinAge = getCoinAge(_address,_now)
 In CraftR.constructor, it can be over/underflowed. check your logic: EXPRESSION maxTotalSupply = 100 * 10 ** 24
 In CraftR.getPosReward, it can be over/underflowed. check your logic: RETURN (_coinAge * interest).div(365 * (10 ** decimals))
 In CraftR.pos, it can be over/underflowed. check your logic: NEW VARIABLE reward = getPosReward(msg.sender)
 In CraftR.ownerMultiSend, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In CraftR.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In CraftR.getCoinAge, it can be over/underflowed. check your logic: EXPRESSION _coinAge = _coinAge.add(uint256(txIns[_address][i].amount) * nCoinSeconds.div(86400))
 In CraftR.ownerMultiSend, it can be over/underflowed. check your logic: EXPRESSION txIns[_recipients[j]].push(transferInStruct(uint128(_values[j]),_now))
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In CraftR.getPosReward, it can be over/underflowed. check your logic: EXPRESSION interest = (435 * defaultPOS).div(100)
 In CraftR.ownerMultiSend, it can be over/underflowed. check your logic: EXPRESSION j ++
 In CraftR.pos, it can be over/underflowed. check your logic: EXPRESSION txIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))
 In CraftR.transferFrom, it can be over/underflowed. check your logic: EXPRESSION txIns[_from].push(transferInStruct(uint128(balances[_from]),_now))
 In CraftR.transfer, it can be over/underflowed. check your logic: EXPRESSION txIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))
 In CraftR.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT defaultPOS = 10 ** 17
 In CraftR.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In CraftR.ownerBurnTokens, it can be over/underflowed. check your logic: EXPRESSION txIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)))
 In CraftR.constructor, it can be over/underflowed. check your logic: EXPRESSION totalInitialSupply = 60 * 10 ** 24
 In CraftR.annualPos, it can be over/underflowed. check your logic: EXPRESSION interest = (435 * defaultPOS).div(100)
 In CraftR.ownerMultiSend, it can be over/underflowed. check your logic: EXPRESSION txIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now))
 In CraftR.ownerBurnTokens, it can be over/underflowed. check your logic: EXPRESSION maxTotalSupply = maxTotalSupply.sub(_value * 10)
 In CraftR.transferFrom, it can be over/underflowed. check your logic: EXPRESSION txIns[_to].push(transferInStruct(uint128(_value),_now))
 In CraftR.coinAge, it can be over/underflowed. check your logic: EXPRESSION myCoinAge = getCoinAge(msg.sender,now)
 In CraftR.getCoinAge, it can be over/underflowed. check your logic: EXPRESSION i ++
 In CraftR.transfer, it can be over/underflowed. check your logic: RETURN pos()
 
line_number: 179
line_number: 181
line_number: 202
line_number: 204
line_number: 206
line_number: 331
line_number: 336
line_number: 338

Filename: 0x284399c033bd1c4ec811ed6ea1f1a8a1f18d7541_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In BOGGED.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In BOGGED.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,amount)
 In BOGGED.transferFrom, it can be over/underflowed. check your logic: NEW VARIABLE tokensToBurn = findBurnAmount(value)
 In BOGGED.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,_totalSupply)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.ceil, it can be over/underflowed. check your logic: RETURN mul(div(d,m),m)
 In BOGGED.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _totalSupply = 100000 * 1e18
 In BOGGED.transfer, it can be over/underflowed. check your logic: NEW VARIABLE tokensToBurn = findBurnAmount(value)
 In SafeMath.ceil, it can be over/underflowed. check your logic: NEW VARIABLE c = add(a,m)
 In SafeMath.ceil, it can be over/underflowed. check your logic: NEW VARIABLE d = sub(c,1)
 
line_number: 167
line_number: 205

Filename: 0x2867e2d426c091c07d5d32fdbd58bd8b0259b092_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In BountiesMetaTxRelayer.metaChangeDeadline, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In ERC721BasicTokenMock.transferFrom, it can be over/underflowed. check your logic: EXPRESSION removeTokenFrom(_from,_tokenId)
 In StandardBounties.refundMyContributions, it can be over/underflowed. check your logic: EXPRESSION i ++
 In ERC20Token.transferFrom, it can be over/underflowed. check your logic: EXPRESSION balances[_from] -= _value
 In ERC721BasicTokenMock.burn, it can be over/underflowed. check your logic: EXPRESSION super._burn(ownerOf(_tokenId),_tokenId)
 In ERC20Token.transfer, it can be over/underflowed. check your logic: EXPRESSION balances[_to] += _value
 In BountiesMetaTxRelayer.metaDrainBounty, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In ERC721BasicTokenMock.transferFrom, it can be over/underflowed. check your logic: EXPRESSION addTokenTo(_to,_tokenId)
 In StandardBounties.drainBounty, it can be over/underflowed. check your logic: EXPRESSION transferTokens(_bountyId,_sender,_amounts[0])
 In StandardBounties.refundMyContributions, it can be over/underflowed. check your logic: EXPRESSION refundContribution(_sender,_bountyId,_contributionIds[i])
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In ERC721BasicToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION addTokenTo(_to,_tokenId)
 In StandardBounties.refundContributions, it can be over/underflowed. check your logic: EXPRESSION i ++
 In BountiesMetaTxRelayer.metaIssueBounty, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaRefundContribution, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In ERC20Token.transfer, it can be over/underflowed. check your logic: EXPRESSION balances[msg.sender] -= _value
 In StandardBounties.addApprovers, it can be over/underflowed. check your logic: EXPRESSION i ++
 In BountiesMetaTxRelayer.metaRefundContributions, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In StandardBounties.refundContribution, it can be over/underflowed. check your logic: EXPRESSION transferTokens(_bountyId,contribution.contributor,contribution.amount)
 In StandardBounties.issueAndContribute, it can be over/underflowed. check your logic: EXPRESSION contribute(_sender,bountyId,_depositAmount)
 In ERC721BasicToken.safeTransferFrom, it can be over/underflowed. check your logic: EXPRESSION transferFrom(_from,_to,_tokenId)
 In BountiesMetaTxRelayer.metaChangeApprover, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaAddApprovers, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In ERC721BasicToken.safeTransferFrom, it can be over/underflowed. check your logic: EXPRESSION safeTransferFrom(_from,_to,_tokenId,)
 In BountiesMetaTxRelayer.metaRefundContribution, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaAddApprovers, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaPerformAction, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaChangeBounty, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaChangeApprover, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.fulfillBounty, it can be over/underflowed. check your logic: EXPRESSION BountyFulfilled(_bountyId,(bounties[_bountyId].fulfillments.length - 1),_fulfillers,_data,_sender)
 In ERC721BasicTokenMock.mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(_to,_tokenId)
 In BountiesMetaTxRelayer.metaFulfillAndAccept, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.drainBounty, it can be over/underflowed. check your logic: EXPRESSION i ++
 In BountiesMetaTxRelayer.metaContribute, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In ERC721BasicToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION removeTokenFrom(_from,_tokenId)
 In ERC721BasicTokenMock.safeTransferFrom, it can be over/underflowed. check your logic: EXPRESSION safeTransferFrom(_from,_to,_tokenId,)
 In BountiesMetaTxRelayer.metaPerformAction, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaDrainBounty, it can be over/underflowed. check your logic: NEW VARIABLE signer = address(uint160(getSigner(metaHash,_signature)))
 In StandardBounties.acceptFulfillment, it can be over/underflowed. check your logic: EXPRESSION i ++
 In StandardBounties.addIssuers, it can be over/underflowed. check your logic: EXPRESSION i ++
 In StandardBounties.addApprovers, it can be over/underflowed. check your logic: EXPRESSION bounties[_bountyId].approvers.push(_approvers[i])
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In BountiesMetaTxRelayer.metaChangeIssuer, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaContribute, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In BountiesMetaTxRelayer.metaRefundMyContributions, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In StandardBounties.fulfillBounty, it can be over/underflowed. check your logic: EXPRESSION bounties[_bountyId].fulfillments.push(Fulfillment(_fulfillers,_sender))
 In StandardBounties.acceptFulfillment, it can be over/underflowed. check your logic: EXPRESSION transferTokens(_bountyId,fulfillment.fulfillers[i],_tokenAmounts[i])
 In BountiesMetaTxRelayer.metaAcceptFulfillment, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaChangeData, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.addIssuers, it can be over/underflowed. check your logic: EXPRESSION bounties[_bountyId].issuers.push(_issuers[i])
 In BountiesMetaTxRelayer.metaUpdateFulfillment, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaRefundContributions, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaChangeDeadline, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.drainBounty, it can be over/underflowed. check your logic: EXPRESSION transferTokens(_bountyId,_sender,_amounts[i])
 In BountiesMetaTxRelayer.metaIssueAndContribute, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.contribute, it can be over/underflowed. check your logic: EXPRESSION ContributionAdded(_bountyId,bounties[_bountyId].contributions.length - 1,_sender,_amount)
 In BountiesMetaTxRelayer.metaIssueAndContribute, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,signature)
 In ERC721BasicTokenMock.safeTransferFrom, it can be over/underflowed. check your logic: EXPRESSION transferFrom(_from,_to,_tokenId)
 In ERC721BasicTokenMock._mint, it can be over/underflowed. check your logic: EXPRESSION addTokenTo(_to,_tokenId)
 In BountiesMetaTxRelayer.metaFulfillBounty, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.fulfillAndAccept, it can be over/underflowed. check your logic: EXPRESSION acceptFulfillment(_sender,_bountyId,bounties[_bountyId].fulfillments.length - 1,_approverId,_tokenAmounts)
 In StandardBounties.contribute, it can be over/underflowed. check your logic: EXPRESSION bounties[_bountyId].contributions.push(Contribution(_sender,_amount,false))
 In BountiesMetaTxRelayer.metaAcceptFulfillment, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In ERC20Token.transferFrom, it can be over/underflowed. check your logic: EXPRESSION balances[_to] += _value
 In BountiesMetaTxRelayer.metaRefundMyContributions, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In BountiesMetaTxRelayer.metaFulfillBounty, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In ERC721BasicTokenMock._burn, it can be over/underflowed. check your logic: EXPRESSION removeTokenFrom(_owner,_tokenId)
 In ERC721BasicToken._mint, it can be over/underflowed. check your logic: EXPRESSION addTokenTo(_to,_tokenId)
 In BountiesMetaTxRelayer.metaChangeBounty, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In ERC721BasicToken._burn, it can be over/underflowed. check your logic: EXPRESSION removeTokenFrom(_owner,_tokenId)
 In BountiesMetaTxRelayer.metaIssueBounty, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,signature)
 In ERC20Token.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowed[_from][msg.sender] -= _value
 In StandardBounties.issueAndContribute, it can be over/underflowed. check your logic: NEW VARIABLE bountyId = issueBounty(_sender,_issuers,_approvers,_data,_deadline,_token,_tokenVersion)
 In BountiesMetaTxRelayer.metaUpdateFulfillment, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 In StandardBounties.fulfillAndAccept, it can be over/underflowed. check your logic: EXPRESSION fulfillBounty(_sender,_bountyId,_fulfillers,_data)
 In BountiesMetaTxRelayer.getSigner, it can be over/underflowed. check your logic: EXPRESSION v += 27
 In BountiesMetaTxRelayer.metaAddIssuers, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaChangeIssuer, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaFulfillAndAccept, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In BountiesMetaTxRelayer.metaChangeData, it can be over/underflowed. check your logic: NEW VARIABLE signer = getSigner(metaHash,_signature)
 In StandardBounties.refundContributions, it can be over/underflowed. check your logic: EXPRESSION transferTokens(_bountyId,contribution.contributor,contribution.amount)
 In BountiesMetaTxRelayer.metaAddIssuers, it can be over/underflowed. check your logic: EXPRESSION replayNonce[signer] ++
 
line_number: 949
line_number: 955

Filename: 0x298b28BEf5E0847C0F4fD8ac615bcA5f6F4B7491_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In DappChannel.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = 1000000 * (10 ** decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 94
line_number: 96
line_number: 138
line_number: 151

Filename: 0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
Moloch.slitherConstructorConstantVariables() (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#7-416) uses literals with too many digits: 18 recommended suffix: ether
	- MAX_DILUTION_BOUND = 10 ** 18 (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#31)
 Moloch.slitherConstructorConstantVariables() (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#7-416) uses literals with too many digits: 18 recommended suffix: ether
	- MAX_VOTING_PERIOD_LENGTH = 10 ** 18 (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#29)
 Moloch.slitherConstructorConstantVariables() (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#7-416) uses literals with too many digits: 18 recommended suffix: ether
	- MAX_NUMBER_OF_SHARES = 10 ** 18 (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#32)
 Moloch.slitherConstructorConstantVariables() (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#7-416) uses literals with too many digits: 18 recommended suffix: ether
	- MAX_GRACE_PERIOD_LENGTH = 10 ** 18 (0x2ada3f0bedaffb5f3dfe0aeac43ac34f893d02ea_integerOverflow.sol#30)
 check: over-underflow
impact: Low
confidence: Low
description
In Moloch.hasVotingPeriodExpired, it can be over/underflowed. check your logic: RETURN getCurrentPeriod() >= startingPeriod.add(votingPeriodLength)
 In Moloch.abort, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(getCurrentPeriod() < proposal.startingPeriod.add(abortWindow),Moloch::abort - abort window must not have passed)
 In Moloch.submitProposal, it can be over/underflowed. check your logic: EXPRESSION proposalQueue.push(proposal)
 In Moloch.submitProposal, it can be over/underflowed. check your logic: EXPRESSION startingPeriod = max(getCurrentPeriod(),0).add(1)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Moloch.submitVote, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(getCurrentPeriod() >= proposal.startingPeriod,Moloch::submitVote - voting period has not started)
 In Moloch.submitVote, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(! hasVotingPeriodExpired(proposal.startingPeriod),Moloch::submitVote - proposal voting period has expired)
 In Moloch.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_NUMBER_OF_SHARES = 10 ** 18
 In Moloch.submitProposal, it can be over/underflowed. check your logic: EXPRESSION startingPeriod = max(getCurrentPeriod(),proposalQueue[proposalQueue.length.sub(1)].startingPeriod).add(1)
 In MolochSummoner.summonMoloch, it can be over/underflowed. check your logic: EXPRESSION Molochs.push(address(M))
 In Moloch.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_DILUTION_BOUND = 10 ** 18
 In Moloch.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_VOTING_PERIOD_LENGTH = 10 ** 18
 In Moloch.processProposal, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(getCurrentPeriod() >= proposal.startingPeriod.add(votingPeriodLength).add(gracePeriodLength),Moloch::processProposal - proposal is not ready to be processed)
 In Moloch.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_GRACE_PERIOD_LENGTH = 10 ** 18
 
line_number: 336

Filename: 0x2b6dd33b57579d93f0fb799abbc47e16d589a024_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In StandardToken.transfer, it can be over/underflowed. check your logic: RETURN transferToContract(_to,_value,empty)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Views.transfer, it can be over/underflowed. check your logic: RETURN transferToContract(_to,_value,empty)
 In Views.transfer, it can be over/underflowed. check your logic: RETURN transferToAddress(_to,_value,empty)
 In StandardToken.transfer, it can be over/underflowed. check your logic: RETURN transferToAddress(_to,_value,_data)
 In Views.transfer, it can be over/underflowed. check your logic: RETURN transferToContract(_to,_value,_data)
 In StandardToken.transfer, it can be over/underflowed. check your logic: RETURN transferToContract(_to,_value,_data)
 In StandardToken.transfer, it can be over/underflowed. check your logic: RETURN transferToAddress(_to,_value,empty)
 In Views.transfer, it can be over/underflowed. check your logic: RETURN transferToAddress(_to,_value,_data)
 
line_number: 158
line_number: 177
line_number: 188

Filename: 0x2bd057cfdeeb330132ed5a820d9690f3b279c7a6_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In crad.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT initialSupply = 10000000 * 10 ** uint256(decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 
line_number: 152
line_number: 154

Filename: 0x3054748ef31cc936e4f057c89078a4a8574fa5e9_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = unlock[readIndex]
 In ERC20Like.uint2str, it can be over/underflowed. check your logic: EXPRESSION len ++
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = balance[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE receipt = new string(blockStart.length + chargeLabel.length + charge.length + unlockLabel.length + unlock.length + balanceLabel.length + balance.length + blockEnd.length)
 In SymToken.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 900000000 * (10 ** decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = chargeLabel[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = blockStart[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = unlockLabel[readIndex]
 In ERC20Like.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SymToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ERC20Like.uint2str, it can be over/underflowed. check your logic: EXPRESSION bstr[k --] = bytes1(uint8(48 + _i % 10))
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE charge = bytes(uint2str(_tokenContainers[holder].chargeAmount))
 In ERC20Like.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = blockEnd[readIndex]
 In SymToken.uint2str, it can be over/underflowed. check your logic: NEW VARIABLE k = len - 1
 In SymToken.uint2str, it can be over/underflowed. check your logic: EXPRESSION bstr[k --] = bytes1(uint8(48 + _i % 10))
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = unlockLabel[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = chargeLabel[readIndex]
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = blockEnd[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION readIndex ++
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE balance = bytes(uint2str(_tokenContainers[holder].balance))
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE receipt = new string(blockStart.length + chargeLabel.length + charge.length + unlockLabel.length + unlock.length + balanceLabel.length + balance.length + blockEnd.length)
 In SymToken.uint2str, it can be over/underflowed. check your logic: EXPRESSION len ++
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = balanceLabel[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE balance = bytes(uint2str(_tokenContainers[holder].balance))
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = balance[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE unlock = bytes(uint2str(_tokenContainers[holder].unlockAmount))
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = charge[readIndex]
 In ERC20Like.uint2str, it can be over/underflowed. check your logic: NEW VARIABLE k = len - 1
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE unlock = bytes(uint2str(_tokenContainers[holder].unlockAmount))
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = unlock[readIndex]
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION readIndex ++
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = charge[readIndex]
 In SymToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = blockStart[readIndex]
 In SymToken.receiptAccountOf, it can be over/underflowed. check your logic: EXPRESSION receiptBytes[writeIndex ++] = balanceLabel[readIndex]
 In ERC20Like.receiptAccountOf, it can be over/underflowed. check your logic: NEW VARIABLE charge = bytes(uint2str(_tokenContainers[holder].chargeAmount))
 
line_number: 348
line_number: 367
line_number: 369
line_number: 525
line_number: 546
line_number: 548
line_number: 575
line_number: 577
line_number: 579
line_number: 600
line_number: 620

Filename: 0x33e1b26d699d923e4cdba286cc5783d3c04831c3_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
TokenERC20.constructor() (0x33e1b26d699d923e4cdba286cc5783d3c04831c3_integerOverflow.sol#86-93) uses literals with too many digits: 12 recommended suffix: szabo
	- _totalSupply = 10 ** 12 * 10 ** uint256(decimals) (0x33e1b26d699d923e4cdba286cc5783d3c04831c3_integerOverflow.sol#90)
 check: over-underflow
impact: Low
confidence: Low
description
In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 10 ** 12 * 10 ** uint256(decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In ART.tokenSale, it can be over/underflowed. check your logic: EXPRESSION sTot ++
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In ART.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 10 ** 12 * 10 ** uint256(decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In ART.getAirdrop, it can be over/underflowed. check your logic: EXPRESSION aTot ++
 In ART.tokenSale, it can be over/underflowed. check your logic: EXPRESSION _tkns = sChunk * _price
 
line_number: 102
line_number: 104
line_number: 115
line_number: 117
line_number: 119

Filename: 0x385351ff78653c3226f4a1d67a332dc05f731f0b_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In Ether5.withdrawIncome, it can be over/underflowed. check your logic: EXPRESSION settleIncome(_playerAddress,_amountLeft)
 In Ether5.getPlayerInfo, it can be over/underflowed. check your logic: EXPRESSION remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In Ether5.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Ether5.fallback, it can be over/underflowed. check your logic: EXPRESSION playGame(address(0x0))
 In Ether5.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,temp)
 In Ether5.constructor, it can be over/underflowed. check your logic: EXPRESSION round[1].endTime = now + poolTime
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Ether5.settleIncome, it can be over/underflowed. check your logic: IF now > player[_playerAddress].lastSettledTime + payoutPeriod
 In Ether5.referralBonusTransferDirect, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Ether5.startNewRound, it can be over/underflowed. check your logic: EXPRESSION _roundID ++
 In Ether5.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In Ether5.playGame, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDirect(msg.sender,amount.mul(20).div(100))
 In Ether5.referralBonusTransferDirect, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In Ether5.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,_dailyIncome.mul(remainingTimeForPayout))
 In Ether5.withdrawIncome, it can be over/underflowed. check your logic: NEW VARIABLE _earnings = player[_playerAddress].dailyIncome + player[_playerAddress].directReferralIncome + player[_playerAddress].roiReferralIncome
 In Ether5.getPlayerInfo, it can be over/underflowed. check your logic: IF player[_playerAddress].lastSettledTime + payoutPeriod >= now
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In Ether5.startNewRound, it can be over/underflowed. check your logic: EXPRESSION roundID ++
 
line_number: 649
line_number: 658
line_number: 665
line_number: 667

Filename: 0x385baa6B28106672e6B11b014F5A8EDB4ac04dE1_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In HDTBNBPool.getReward, it can be over/underflowed. check your logic: NEW VARIABLE reward = earned(msg.sender)
 In HDTBNBPool.getReward, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In HDTBNBPool.exit, it can be over/underflowed. check your logic: EXPRESSION getReward()
 In HDTBNBPool.stake, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In HDTBNBPool.stake, it can be over/underflowed. check your logic: EXPRESSION super.stake(amount)
 In HDTBNBPool.exit, it can be over/underflowed. check your logic: EXPRESSION withdraw(balanceOf(msg.sender))
 In HDTBNBPool.withdraw, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In HDTBNBPool.withdraw, it can be over/underflowed. check your logic: EXPRESSION super.withdraw(amount)
 In HDTBNBPool.notifyRewardAmount, it can be over/underflowed. check your logic: EXPRESSION _checkRewardRate()
 In HDTBNBPool.earned, it can be over/underflowed. check your logic: RETURN balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account])
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In HDTBNBPool.notifyRewardAmount, it can be over/underflowed. check your logic: EXPRESSION updateReward(address(0))
 
line_number: 554
line_number: 556
line_number: 562
line_number: 564

Filename: 0x38c5499ac70df829ba90d05be65f69365ceaeef8_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
SkyWay.slitherConstructorVariables() (0x38c5499ac70df829ba90d05be65f69365ceaeef8_integerOverflow.sol#186-194) uses literals with too many digits: 1000000000e18 recommended suffix: gwei
	- INITIAL_SUPPLY = 1000000000e18 (0x38c5499ac70df829ba90d05be65f69365ceaeef8_integerOverflow.sol#187)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SkyWay.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SkyWay.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SkyWay.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,INITIAL_SUPPLY)
 In SkyWay._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 105
line_number: 115
line_number: 124

Filename: 0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
ShotgunClause.getRequiredWeiForCounterclaim() (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1135-1137) uses literals with too many digits: 18 recommended suffix: ether
	- (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10 ** 18) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1136)
 ShotgunClause.collectShardProceeds() (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1072-1085) uses literals with too many digits: 18 recommended suffix: ether
	- shardsToReceive = (proportionContributed.mul(_initialClaimantBalance)).div(10 ** 18) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1083)
 ShardOffering.contribute() (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1321-1360) uses literals with too many digits: 18 recommended suffix: ether
	- shardAmount = (msg.value.mul(10 ** 18)).div(_pricePerShardInWei) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1350)
 ShotgunClause.collectShardProceeds() (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1072-1085) uses literals with too many digits: 18 recommended suffix: ether
	- proportionContributed = (_counterclaimContribs[msg.sender].mul(10 ** 18)).div(_counterWeiContributed) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1081)
 ShardOffering.constructor(uint256,uint256,uint256,uint256,uint256,uint256) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1298-1314) uses literals with too many digits: 18 recommended suffix: ether
	- _contributionTargetInWei = (pricePerShardInWei.mul(shardAmountOffered)).div(10 ** 18) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1311)
 ShotgunClause.constructor(address,uint256,address) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#979-992) uses literals with too many digits: 18 recommended suffix: ether
	- _pricePerShardInWei = (_initialOfferInWei.mul(10 ** 18)).div(_shardRegistry.cap().sub(_initialClaimantBalance)) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#990)
 ShotgunClause.collectEtherProceeds(uint256,address) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1047-1067) uses literals with too many digits: 18 recommended suffix: ether
	- weiProceeds = (_pricePerShardInWei.mul(balance)).div(10 ** 18) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1053)
 ShotgunClause.collectEtherProceeds(uint256,address) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1047-1067) uses literals with too many digits: 18 recommended suffix: ether
	- amount = (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10 ** 18) (0x3e39505167639ce7852c1f521f2926a01928a0cf_integerOverflow.sol#1060)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20Capped.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ShardRegistry.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(account,amount)
 In ShotgunClause.counterCommitEther, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(msg.value + _counterWeiContributed <= getRequiredWeiForCounterclaim(),[counterCommitEther] Ether exceeds goal)
 In ERC20Pausable.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In ShardOffering.contribute, it can be over/underflowed. check your logic: NEW VARIABLE shardAmount = (msg.value.mul(10 ** 18)).div(_pricePerShardInWei)
 In ShotgunClause.collectEtherProceeds, it can be over/underflowed. check your logic: NEW VARIABLE weiProceeds = (_pricePerShardInWei.mul(balance)).div(10 ** 18)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In ERC20Burnable.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(account,amount)
 In ShotgunClause.getRequiredWeiForCounterclaim, it can be over/underflowed. check your logic: RETURN (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10 ** 18)
 In ERC20Burnable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In ShardGovernor.checkShotgunState, it can be over/underflowed. check your logic: NEW VARIABLE _shotgunClause = ShotgunClause(_shotgunAddressArray[_shotgunCounter - 1])
 In ERC20Mintable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ERC20Capped.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(account,amount)
 In ShardOffering.contribute, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(msg.value <= _contributionTargetInWei - _totalWeiContributed,[contribute] Ether value exceeds remaining quota)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In ShotgunClause.collectShardProceeds, it can be over/underflowed. check your logic: NEW VARIABLE proportionContributed = (_counterclaimContribs[msg.sender].mul(10 ** 18)).div(_counterWeiContributed)
 In ShotgunClause.constructor, it can be over/underflowed. check your logic: EXPRESSION _pricePerShardInWei = (_initialOfferInWei.mul(10 ** 18)).div(_shardRegistry.cap().sub(_initialClaimantBalance))
 In ShardOffering.contribute, it can be over/underflowed. check your logic: EXPRESSION _contributors.push(msg.sender)
 In ERC20Pausable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ShotgunClause.counterCommitEther, it can be over/underflowed. check your logic: IF _counterWeiContributed == getRequiredWeiForCounterclaim()
 In ShardRegistry._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In ShardRegistry.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_msgSender(),amount)
 In ShardRegistry.lockShardsAndClaim, it can be over/underflowed. check your logic: EXPRESSION transfer(address(_shardGovernor),balanceOf(msg.sender))
 In ShotgunClause.collectShardProceeds, it can be over/underflowed. check your logic: NEW VARIABLE shardsToReceive = (proportionContributed.mul(_initialClaimantBalance)).div(10 ** 18)
 In ShardOffering.constructor, it can be over/underflowed. check your logic: EXPRESSION _contributionTargetInWei = (pricePerShardInWei.mul(shardAmountOffered)).div(10 ** 18)
 In ShardGovernor.claimInitialShotgun, it can be over/underflowed. check your logic: EXPRESSION _shotgunCounter ++
 In ERC20Mintable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In ShotgunClause.counterCommitEther, it can be over/underflowed. check your logic: EXPRESSION _counterclaimants.push(msg.sender)
 In ShardGovernor.claimInitialShotgun, it can be over/underflowed. check your logic: EXPRESSION _shotgunAddressArray.push(address(_currentShotgunClause))
 In ShardRegistry.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In ShardRegistry.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(account,amount)
 In ERC20Pausable.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In ShardRegistry.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In ShotgunClause.constructor, it can be over/underflowed. check your logic: EXPRESSION _deadlineTimestamp = now.add(1 * 1209600)
 In ERC20Capped._mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(account,value)
 In ERC20Burnable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ShotgunClause.collectEtherProceeds, it can be over/underflowed. check your logic: NEW VARIABLE amount = (_pricePerShardInWei.mul(_initialClaimantBalance)).div(10 ** 18)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In ShardRegistry.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In ERC20Mintable.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(account,amount)
 In ERC20Capped._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ShardRegistry.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In ERC20Burnable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In ShardRegistry.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In ERC20Burnable.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_msgSender(),amount)
 In ERC20Mintable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ShardRegistry.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In ShardRegistry._mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(account,value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In ShardRegistry.burnAndCollectEther, it can be over/underflowed. check your logic: EXPRESSION burn(balance)
 In ERC20Capped.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 
line_number: 1312

Filename: 0x43d99d54f14c64994fd9666beab6023b0069de20_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
SafeMath.slitherConstructorConstantVariables() (0x43d99d54f14c64994fd9666beab6023b0069de20_integerOverflow.sol#744-805) uses literals with too many digits: 255 recommended suffix: ether
	- INT256_MIN = - 2 ** 255 (0x43d99d54f14c64994fd9666beab6023b0069de20_integerOverflow.sol#745)
 check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INT256_MIN = - 2 ** 255
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In NEST_3_OfferContract.changeOfferEth, it can be over/underflowed. check your logic: EXPRESSION require(bool)(checkContractState() == 0)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In NEST_3_OfferContract.changeOfferErc, it can be over/underflowed. check your logic: EXPRESSION require(bool)(checkContractState() == 0)
 In NEST_3_OfferContract.turnOut, it can be over/underflowed. check your logic: EXPRESSION require(bool)(checkContractState() == 1)
 
line_number: 535
line_number: 537
line_number: 592
line_number: 594

Filename: 0x440a803b42a78d93a1fe5da29a9fb37ecf193786_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
Polaris._percentChange(Polaris.Checkpoint,Polaris.Checkpoint) (0x440a803b42a78d93a1fe5da29a9fb37ecf193786_integerOverflow.sol#782-787) uses literals with too many digits: 18 recommended suffix: ether
	- diff.mul(10 ** 18).div(a) (0x440a803b42a78d93a1fe5da29a9fb37ecf193786_integerOverflow.sol#786)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Polaris._isSubscriber, it can be over/underflowed. check your logic: RETURN account.balance > _getOwedAmount(account)
 In Polaris.poke, it can be over/underflowed. check your logic: EXPRESSION medianizer.median = _medianize(medianizer.prices)
 In Polaris._medianize, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Polaris.willRewardCheckpoint, it can be over/underflowed. check your logic: RETURN _willRewardCheckpoint(token,checkpoint)
 In Polaris._initializeMedianizer, it can be over/underflowed. check your logic: EXPRESSION medianizer.prices.push(checkpoint)
 In Polaris.subscribe, it can be over/underflowed. check your logic: EXPRESSION _collect(token,account)
 In Polaris.poke, it can be over/underflowed. check your logic: EXPRESSION medianizer.pending.push(checkpoint)
 In OracleToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,amount)
 In Polaris.poke, it can be over/underflowed. check your logic: EXPRESSION medianizer.prices[medianizer.tail] = _medianize(medianizer.pending)
 In Polaris._initializeMedianizer, it can be over/underflowed. check your logic: EXPRESSION i ++
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In Polaris.getDestAmount, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(dest == ETHER || _isSubscriber(accounts[dest][msg.sender]),Polaris::getDestAmount: Not subscribed)
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In OracleToken.redeem, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,amount)
 In Polaris._collect, it can be over/underflowed. check your logic: NEW VARIABLE owedAmount = _getOwedAmount(account)
 In Polaris.poke, it can be over/underflowed. check your logic: EXPRESSION medianizer.tail = (medianizer.tail + 1) % MAX_CHECKPOINTS
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In OracleToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In Polaris.getOwedAmount, it can be over/underflowed. check your logic: RETURN _getOwedAmount(account)
 In Polaris._medianize, it can be over/underflowed. check your logic: EXPRESSION storeIndex ++
 In Polaris.poke, it can be over/underflowed. check your logic: IF _willRewardCheckpoint(token,checkpoint)
 In Polaris._percentChange, it can be over/underflowed. check your logic: RETURN diff.mul(10 ** 18).div(a)
 In Polaris._initializeMedianizer, it can be over/underflowed. check your logic: EXPRESSION medianizer.pending.push(checkpoint)
 In Polaris._willRewardCheckpoint, it can be over/underflowed. check your logic: RETURN (medianizer.prices.length < MAX_CHECKPOINTS || block.timestamp.sub(medianizer.latestTimestamp) >= MAX_TIME_SINCE_LAST_CHECKPOINT || (block.timestamp.sub(medianizer.pendingStartTimestamp) >= PENDING_PERIOD && _percentChange(medianizer.median,checkpoint) >= MIN_PRICE_CHANGE) || _percentChange(medianizer.prices[medianizer.tail],checkpoint) >= MIN_PRICE_CHANGE || _percentChange(medianizer.pending[medianizer.pending.length.sub(1)],checkpoint) >= MIN_PRICE_CHANGE)
 In Polaris.getDestAmount, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(src == ETHER || _isSubscriber(accounts[src][msg.sender]),Polaris::getDestAmount: Not subscribed)
 In Polaris._medianize, it can be over/underflowed. check your logic: IF _isLessThan(checkpoints[i],pivotCheckpoint)
 In Polaris.unsubscribe, it can be over/underflowed. check your logic: EXPRESSION _collect(token,account)
 In Polaris.poke, it can be over/underflowed. check your logic: EXPRESSION _initializeMedianizer(token,checkpoint)
 In OracleToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Polaris.collect, it can be over/underflowed. check your logic: EXPRESSION _collect(token,account)
 In Polaris.getMedianizer, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_isSubscriber(accounts[token][msg.sender]) || _isHuman(),Polaris::getMedianizer: Not subscribed)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In OracleToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 
line_number: 260
line_number: 280
line_number: 299

Filename: 0x448a3a18c0c06335edda45cb3fd2fe5a87c020e7_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x448a3a18c0c06335edda45cb3fd2fe5a87c020e7_integerOverflow.sol#2039-2077) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(proposal.totalStakes <= 0x100000000000000000000000000000000,total stakes is too high) (0x448a3a18c0c06335edda45cb3fd2fe5a87c020e7_integerOverflow.sol#2067)
 GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x448a3a18c0c06335edda45cb3fd2fe5a87c020e7_integerOverflow.sol#2039-2077) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(staker.amount <= 0x100000000000000000000000000000000,staking amount is too high) (0x448a3a18c0c06335edda45cb3fd2fe5a87c020e7_integerOverflow.sol#2066)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply - amountBurned)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In ERC20Burnable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In DAOToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceFrom = balanceOf(_user)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In ERC20Burnable.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In GenesisProtocolLogic.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION realResult = mul(realResult,tempRealBase)
 In GenesisProtocol.vote, it can be over/underflowed. check your logic: RETURN internalVote(_proposalId,voter,_vote,_amount)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(curTotalSupply + _amount >= curTotalSupply)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE mid = (max + min + 1) / 2
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: IF (checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In Reputation.totalSupply, it can be over/underflowed. check your logic: RETURN totalSupplyAt(block.number)
 In GenesisProtocol.score, it can be over/underflowed. check your logic: RETURN _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.balanceOf, it can be over/underflowed. check your logic: RETURN balanceOfAt(_owner,block.number)
 In DAOToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GenesisProtocolLogic.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE oldCheckPoint = checkpoints[checkpoints.length - 1]
 In RealMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE res = realA * realB
 In GenesisProtocol.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceTo = balanceOf(_user)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: IF _block >= checkpoints[checkpoints.length - 1].fromBlock
 In GenesisProtocol.execute, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION tempRealBase = mul(tempRealBase,tempRealBase)
 In GenesisProtocol.stakeWithSignature, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,staker)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.totalSupplyAt, it can be over/underflowed. check your logic: RETURN getValueAt(totalSupplyHistory,_blockNumber)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.balanceOfAt, it can be over/underflowed. check your logic: RETURN getValueAt(balances[_owner],_blockNumber)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(previousBalanceTo + _amount >= previousBalanceTo)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: RETURN checkpoints[checkpoints.length - 1].value
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceTo + _amount)
 In GenesisProtocol.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE max = checkpoints.length - 1
 In Reputation.getValueAt, it can be over/underflowed. check your logic: EXPRESSION max = mid - 1
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In DAOToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In ERC20Burnable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In RealMath.fraction, it can be over/underflowed. check your logic: RETURN div(uint256(numerator) * REAL_ONE,uint256(denominator) * REAL_ONE)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In GenesisProtocol.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In ERC20Burnable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Burnable.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In DAOToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE newCheckPoint = checkpoints[checkpoints.length ++]
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In DAOToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(_to,_amount)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocol.stake, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,msg.sender)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In DAOToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceFrom - amountBurned)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In RealMath.div, it can be over/underflowed. check your logic: RETURN uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator))
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 
line_number: 1838

Filename: 0x469202bb405f940cd908ddbc28155a70703a4840_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
Full.slitherConstructorVariables() (0x469202bb405f940cd908ddbc28155a70703a4840_integerOverflow.sol#184-192) uses literals with too many digits: 1000000000e4 recommended suffix: gwei
	- INITIAL_SUPPLY = 1000000000e4 (0x469202bb405f940cd908ddbc28155a70703a4840_integerOverflow.sol#185)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In Full.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,INITIAL_SUPPLY)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Full._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Full.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In Full.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 103
line_number: 113
line_number: 122

Filename: 0x508b2b1dd87fa37238e008dc00b47f433aa8c4b1_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Sharkbit.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In Sharkbit.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 13000 * decimalFactor
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0x524d76a99a48a9761f9a5f9f6a050b406043912d_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
ANASH.slitherConstructorConstantVariables() (0x524d76a99a48a9761f9a5f9f6a050b406043912d_integerOverflow.sol#217-254) uses literals with too many digits: 20000000000 recommended suffix: gwei
	- premined = 20000000000 (0x524d76a99a48a9761f9a5f9f6a050b406043912d_integerOverflow.sol#221)
 check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In ANASH.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In TokenStandard.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenBasic.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In ANASH.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In TokenStandard.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 
line_number: 113
line_number: 121
line_number: 165
line_number: 173
line_number: 198
line_number: 209

Filename: 0x528732d7ff76a31bd419f1d57d549d7643c02db2_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In GLDS.addB25, it can be over/underflowed. check your logic: EXPRESSION keyListB25.push(_key)
 In GLDS.sumB10List, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION transferFrom(_walletB10,beneficiary,FromWalletB10)
 In GLDS.removeB25, it can be over/underflowed. check your logic: EXPRESSION keyListB25.length --
 In GLDS.removeB10, it can be over/underflowed. check your logic: EXPRESSION keyListB10.length --
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION transferFrom(_walletB25,beneficiary,FromWalletB25)
 In GLDS.addPay, it can be over/underflowed. check your logic: EXPRESSION keyList.push(_key)
 In GLDS.removeB20, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = bonus20.index - 1
 In GLDS.addB20, it can be over/underflowed. check your logic: EXPRESSION bonus20.index = keyListIndex + 1
 In GLDS.addB25, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = keyListB25.length - 1
 In GLDS.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,_initSupply)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In GLDS.addPay, it can be over/underflowed. check your logic: EXPRESSION pay.valueETH += _valueETH
 In GLDS.addB10, it can be over/underflowed. check your logic: EXPRESSION bonus10.valueGLDS += _valueGLDS
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GLDS.sumB25List, it can be over/underflowed. check your logic: EXPRESSION sum += awaitB25[keyListB25[i]].valueGLDS
 In GLDS.payTokens, it can be over/underflowed. check your logic: EXPRESSION nonReentrant()
 In GLDS.addB20, it can be over/underflowed. check your logic: EXPRESSION bonus20.valueGLDS += _valueGLDS
 In GLDS.transferOwner, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GLDS.removeB25, it can be over/underflowed. check your logic: EXPRESSION awaitB25[keyListB25[keyListLastIndex]].index = keyListIndex + 1
 In GLDS.payTokens, it can be over/underflowed. check your logic: EXPRESSION addPay(beneficiary,weiAmount)
 In GLDS.addPay, it can be over/underflowed. check your logic: EXPRESSION pay.index = keyListIndex + 1
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION transferFrom(_walletB20,beneficiary,FromWalletB20)
 In GLDS.transferAdminFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION qtyGLDS -= FromWalletB25
 In GLDS.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,value)
 In GLDS.addB20, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = keyListB20.length - 1
 In GLDS.addB20, it can be over/underflowed. check your logic: EXPRESSION keyListB20.push(_key)
 In GLDS._transfer, it can be over/underflowed. check your logic: EXPRESSION addB10(to,value)
 In GLDS.constructor, it can be over/underflowed. check your logic: EXPRESSION _initSupply = initSupply.mul(10 ** uint256(decimals))
 In GLDS.removePay, it can be over/underflowed. check your logic: EXPRESSION awaitGLDS[keyList[keyListLastIndex]].index = keyListIndex + 1
 In GLDS.removeB20, it can be over/underflowed. check your logic: NEW VARIABLE keyListLastIndex = keyListB20.length - 1
 In GLDS.removePay, it can be over/underflowed. check your logic: EXPRESSION keyList.length --
 In GLDS.addPay, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = keyList.length - 1
 In GLDS.sumB20List, it can be over/underflowed. check your logic: EXPRESSION sum += awaitB20[keyListB20[i]].valueGLDS
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION qtyGLDS -= FromWalletB10
 In GLDS.chargeWalletsTokenSale, it can be over/underflowed. check your logic: EXPRESSION transfer(_walletB20,AmountB20)
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GLDS.chargeWalletsTokenSale, it can be over/underflowed. check your logic: EXPRESSION transfer(_walletB25,AmountB25)
 In GLDS.addB25, it can be over/underflowed. check your logic: EXPRESSION bonus25.valueGLDS += _valueGLDS
 In GLDS.addB25, it can be over/underflowed. check your logic: EXPRESSION bonus25.index = keyListIndex + 1
 In GLDS.removeB25, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = bonus25.index - 1
 In GLDS.addB10, it can be over/underflowed. check your logic: EXPRESSION bonus10.index = keyListIndex + 1
 In GLDS.removeB25, it can be over/underflowed. check your logic: NEW VARIABLE keyListLastIndex = keyListB25.length - 1
 In GLDS.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GLDS.sumB20List, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GLDS.sumB25List, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GLDS.sumB10List, it can be over/underflowed. check your logic: EXPRESSION sum += awaitB10[keyListB10[i]].valueGLDS
 In GLDS.sumAwaitingList, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GLDS.removeB20, it can be over/underflowed. check your logic: EXPRESSION awaitB20[keyListB20[keyListLastIndex]].index = keyListIndex + 1
 In GLDS.fallback, it can be over/underflowed. check your logic: EXPRESSION payTokens(msg.sender,msg.value)
 In GLDS.removeB10, it can be over/underflowed. check your logic: NEW VARIABLE keyListLastIndex = keyListB10.length - 1
 In GLDS.removePay, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = pay.index - 1
 In GLDS.removeB10, it can be over/underflowed. check your logic: EXPRESSION awaitB10[keyListB10[keyListLastIndex]].index = keyListIndex + 1
 In GLDS._transfer, it can be over/underflowed. check your logic: EXPRESSION addB20(to,value)
 In GLDS.transferTokens, it can be over/underflowed. check your logic: EXPRESSION qtyGLDS -= FromWalletB20
 In GLDS.chargeWalletsTokenSale, it can be over/underflowed. check your logic: EXPRESSION transfer(_walletB10,AmountB10)
 In GLDS.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(from,value)
 In GLDS.removePay, it can be over/underflowed. check your logic: NEW VARIABLE keyListLastIndex = keyList.length - 1
 In GLDS.removeB20, it can be over/underflowed. check your logic: EXPRESSION keyListB20.length --
 In GLDS.addB10, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = keyListB10.length - 1
 In GLDS.addB10, it can be over/underflowed. check your logic: EXPRESSION keyListB10.push(_key)
 In GLDS.removeB10, it can be over/underflowed. check your logic: NEW VARIABLE keyListIndex = bonus10.index - 1
 In GLDS.sumAwaitingList, it can be over/underflowed. check your logic: EXPRESSION sum += awaitGLDS[keyList[i]].valueETH
 In GLDS.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GLDS._transfer, it can be over/underflowed. check your logic: EXPRESSION addB25(to,value)
 
line_number: 496
line_number: 514
line_number: 597

Filename: 0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
PARAGON.slitherConstructorConstantVariables() (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#117-524) uses literals with too many digits: 10000000000 recommended suffix: gwei
	- maxTotalSupply = 10000000000 * E18 (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#128)
 PARAGON.slitherConstructorConstantVariables() (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#117-524) uses literals with too many digits: 1000000000000000000 recommended suffix: ether
	- E18 = 1000000000000000000 (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#125)
 PARAGON.slitherConstructorConstantVariables() (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#117-524) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- maxSaleSupply = 2000000000 * E18 (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#130)
 PARAGON.constructor() (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#179-199) uses literals with too many digits: 10000000000 recommended suffix: gwei
	- totalTokenSupply = 10000000000 * E18 (0x535801ba07b9d346b0425d913fbdebd0788c2e40_integerOverflow.sol#185)
 check: over-underflow
impact: Low
confidence: Low
description
In PARAGON.advisorIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.privateUnlock, it can be over/underflowed. check your logic: IF (time >= endSaleTime.add(month * 4)) && (privateFourthWallet[_to] > 0)
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxReserveSupply = 1600000000 * E18
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxCrowdSupply = 1600000000 * E18
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxTotalSupply = 10000000000 * E18
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In PARAGON.seedIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.crowdIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.reserveIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.privateIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.burnToken, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.endSale, it can be over/underflowed. check your logic: EXPRESSION i ++
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxSaleSupply = 2000000000 * E18
 In PARAGON.constructor, it can be over/underflowed. check your logic: EXPRESSION require(bool)(maxTeamSupply == teamVestingSupplyPerTime * teamVestingTime)
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxMktSupply = 2800000000 * E18
 In PARAGON.privateUnlock, it can be over/underflowed. check your logic: IF (time >= endSaleTime.add(month * 3)) && (privateThirdWallet[_to] > 0)
 In PARAGON.privateUnlock, it can be over/underflowed. check your logic: IF (time >= endSaleTime.add(month * 2)) && (privateSecondWallet[_to] > 0)
 In PARAGON.teamIssueVesting, it can be over/underflowed. check your logic: EXPRESSION require(bool)(((endSaleTime + (_time * teamVestingDate)) < time) && (teamVestingTimeAtSupply[_time] > 0))
 In PARAGON.constructor, it can be over/underflowed. check your logic: EXPRESSION require(bool)(maxTotalSupply == maxSaleSupply + maxCrowdSupply + maxMktSupply + maxTeamSupply + maxReserveSupply + maxAdvisorSupply)
 In PARAGON.balanceOf, it can be over/underflowed. check your logic: EXPRESSION balance = balance.add(privateFirstWallet[_who] + privateSecondWallet[_who] + privateThirdWallet[_who] + privateFourthWallet[_who])
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxTeamSupply = 1600000000 * E18
 In PARAGON.publicIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT teamVestingSupplyPerTime = 100000000 * E18
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT teamVestingDate = 2 * month
 In PARAGON.mktIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In PARAGON.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxAdvisorSupply = 400000000 * E18
 In PARAGON.constructor, it can be over/underflowed. check your logic: EXPRESSION totalTokenSupply = 10000000000 * E18
 
line_number: 221
line_number: 254

Filename: 0x565a093f3230ade853c45c5cd7c84344e75b4393_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
EraswapERC20.constructor() (0x565a093f3230ade853c45c5cd7c84344e75b4393_integerOverflow.sol#418-420) uses literals with too many digits: 910000000000000000000000000 recommended suffix: ether
	- mint(msg.sender,910000000000000000000000000) (0x565a093f3230ade853c45c5cd7c84344e75b4393_integerOverflow.sol#419)
 NRTManager.constructor() (0x565a093f3230ade853c45c5cd7c84344e75b4393_integerOverflow.sol#563-568) uses literals with too many digits: 819000000000000000000000000 recommended suffix: ether
	- AnnualNRTAmount = 819000000000000000000000000 (0x565a093f3230ade853c45c5cd7c84344e75b4393_integerOverflow.sol#565)
 check: over-underflow
impact: Low
confidence: Low
description
In PausableEraswap.approve, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In PausableEraswap.transfer, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In PausableEraswap.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(newTalentsAndPartnerships,newTalentsAndPartnershipsBal)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(TimeAlly,TimeAllyNRT)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(researchAndDevelopment,researchAndDevelopmentBal)
 In EraswapToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In EraswapToken.approve, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(contingencyFunds,contingencyFundsBal)
 In PausableEraswap.increaseApproval, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION burnTokens()
 In EraswapERC20.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(contingencyFunds,contingencyFundsBal)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(marketingAndRNR,marketingAndRNRBal)
 In BurnableToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,_value)
 In EraswapERC20.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,_value)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(timeSwappers,timeSwappersNRT)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(TimeAlly,TimeAllyNRT)
 In EraswapToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = _a * _b
 In EraswapToken.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In NRTManager.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,_value)
 In EraswapToken.increaseApproval, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(platformMaintenance,platformMaintenanceBal)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(platformMaintenance,platformMaintenanceBal)
 In EraswapToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In EraswapToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION burnTokens()
 In EraswapToken.UpdateBalance, it can be over/underflowed. check your logic: EXPRESSION require(bool)(transferFrom(msg.sender,TokenTransferList[i],TokenTransferBalance[i]))
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(newTalentsAndPartnerships,newTalentsAndPartnershipsBal)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(buzzCafe,buzzCafeNRT)
 In EraswapToken.constructor, it can be over/underflowed. check your logic: EXPRESSION mint(msg.sender,910000000000000000000000000)
 In EraswapToken.decreaseApproval, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(kmPards,kmPardsBal)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(timeSwappers,timeSwappersNRT)
 In PausableEraswap.constructor, it can be over/underflowed. check your logic: EXPRESSION mint(msg.sender,910000000000000000000000000)
 In PausableEraswap.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In PausableEraswap.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In NRTManager.constructor, it can be over/underflowed. check your logic: EXPRESSION mint(msg.sender,910000000000000000000000000)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(timeSwappers,timeSwappersNRT)
 In EraswapToken.UpdateLuckpool, it can be over/underflowed. check your logic: EXPRESSION require(bool)(transferFrom(msg.sender,address(this),amount))
 In BetDeEx.createBet, it can be over/underflowed. check your logic: EXPRESSION bets.push(address(_newBet))
 In PausableEraswap.decreaseApproval, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(marketingAndRNR,marketingAndRNRBal)
 In NRTManager.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(MaxAmount)
 In PausableEraswap.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(buzzCafe,buzzCafeNRT)
 In EraswapToken.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(MaxAmount)
 In EraswapToken.UpdateBalance, it can be over/underflowed. check your logic: EXPRESSION i ++
 In PausableEraswap.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(burnTokenBal)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = _a + _b
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION burnTokens()
 In EraswapToken.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(burnTokenBal)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(researchAndDevelopment,researchAndDevelopmentBal)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(newTalentsAndPartnerships,newTalentsAndPartnershipsBal)
 In PausableEraswap.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(MaxAmount)
 In EraswapERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION mint(msg.sender,910000000000000000000000000)
 In EraswapToken.transfer, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In PausableEraswap.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In NRTManager.burnTokens, it can be over/underflowed. check your logic: EXPRESSION burn(burnTokenBal)
 In EraswapToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,_value)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(platformMaintenance,platformMaintenanceBal)
 In EraswapToken.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(marketingAndRNR,marketingAndRNRBal)
 In EraswapToken.UpdateBurnBal, it can be over/underflowed. check your logic: EXPRESSION require(bool)(transferFrom(msg.sender,address(this),amount))
 In EraswapToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(contingencyFunds,contingencyFundsBal)
 In NRTManager.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(researchAndDevelopment,researchAndDevelopmentBal)
 In PausableEraswap.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,_value)
 In PausableEraswap.transferFrom, it can be over/underflowed. check your logic: EXPRESSION whenNotPaused()
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(TimeAlly,TimeAllyNRT)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(kmPards,kmPardsBal)
 In CappedToken.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In NRTManager.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(kmPards,kmPardsBal)
 In PausableEraswap.MonthlyNRTRelease, it can be over/underflowed. check your logic: EXPRESSION mint(buzzCafe,buzzCafeNRT)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN _a - _b
 
line_number: 42
line_number: 237
line_number: 318
line_number: 359
line_number: 361
line_number: 724
line_number: 737
line_number: 908
line_number: 915
line_number: 1007
line_number: 1010

Filename: 0x5c2e024d836e651629f0dc18273068424087ac2e_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In aphalius.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 30000 * decimalFactor
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In aphalius.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0x5cd5cff91fc3bfd3aaf1d769b1e040a88266bac5_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GCM.constructor() (0x5cd5cff91fc3bfd3aaf1d769b1e040a88266bac5_integerOverflow.sol#305-315) uses literals with too many digits: 1000000000000000000 recommended suffix: ether
	- totalSupply = 750000000 * 1000000000000000000 (0x5cd5cff91fc3bfd3aaf1d769b1e040a88266bac5_integerOverflow.sol#309)
 check: over-underflow
impact: Low
confidence: Low
description
In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In GCM.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = 750000000 * 1000000000000000000
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GCM.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In GCM.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In GCM.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In GCM.burnTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(msg.sender) >= _tokens)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In GCM.freezeTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(_owner))
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In GCM.transferFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(_from) >= _value)
 In GCM.transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(msg.sender))
 In GCM.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 
line_number: 120
line_number: 122
line_number: 162
line_number: 203
line_number: 214
line_number: 377
line_number: 379

Filename: 0x5e44414f186e763f376e9ede66aec2ac24bea086_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
URACCrowdSale.buyURAC(address) (0x5e44414f186e763f376e9ede66aec2ac24bea086_integerOverflow.sol#633-661) uses literals with too many digits: 100000000000 recommended suffix: gwei
	- require(bool)(tx.gasprice <= 100000000000) (0x5e44414f186e763f376e9ede66aec2ac24bea086_integerOverflow.sol#644)
 check: over-underflow
impact: Low
confidence: Low
description
In URACToken.claimTokens, it can be over/underflowed. check your logic: EXPRESSION i ++
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In URACCrowdSale.buyURAC, it can be over/underflowed. check your logic: EXPRESSION doBuy(receipient,stage)
 In URACToken.claimTokens, it can be over/underflowed. check your logic: EXPRESSION transfer(receipent,lockedBalances[receipent])
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In URACToken.mint, it can be over/underflowed. check your logic: EXPRESSION maxTokenAmountNotReached(amount)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In URACCrowdSale.constructor, it can be over/underflowed. check your logic: EXPRESSION uracToken.mint(otherAddress,OTHER_STAKE * STAKE_MULTIPLIER,false)
 In URACToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In URACCrowdSale.fallback, it can be over/underflowed. check your logic: EXPRESSION buyURAC(msg.sender)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In URACCrowdSale.costAndBuyTokens, it can be over/underflowed. check your logic: EXPRESSION getTokens = exchangeRate * value
 In URACToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In URACToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In URACCrowdSale.constructor, it can be over/underflowed. check your logic: EXPRESSION uracToken.mint(minerAddress,MINER_STAKE * STAKE_MULTIPLIER,false)
 In URACCrowdSale.doBuy, it can be over/underflowed. check your logic: EXPRESSION (toFund,toCollect) = costAndBuyTokens(tokenAvailable,value)
 In URACToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In URACCrowdSale.setWhiteList, it can be over/underflowed. check your logic: EXPRESSION i ++
 In URACCrowdSale.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_OPEN_SOLD = URAC_TOTAL_SUPPLY * OPEN_SALE_STAKE / DIVISOR_STAKE
 In URACCrowdSale.buyURAC, it can be over/underflowed. check your logic: IF startTime <= now && now < startTime + STAGE_1_TIME
 In URACCrowdSale.setStartTime, it can be over/underflowed. check your logic: EXPRESSION endTime = startTime + MAX_SALE_DURATION
 
line_number: 164
line_number: 220
line_number: 264
line_number: 285
line_number: 394
line_number: 396
line_number: 417
line_number: 420
line_number: 423

Filename: 0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
YAMGovernanceToken.safe32(uint256,string) (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#836-839) uses literals with too many digits: 32 recommended suffix: ether
	- require(bool,string)(n < 2 ** 32,errorMessage) (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#837)
 YAMDelegate.slitherConstructorConstantVariables() (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#1383-1417) uses literals with too many digits: 18 recommended suffix: ether
	- BASE = 10 ** 18 (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#548)
 YAMDelegate.slitherConstructorConstantVariables() (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#1383-1417) uses literals with too many digits: 24 recommended suffix: ether
	- internalDecimals = 10 ** 24 (0x6508fb1ed4d7ece18dfff05c834e44124edbd910_integerOverflow.sol#543)
 check: over-underflow
impact: Low
confidence: Low
description
In YAMToken._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],yamValue)
 In YAM._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],yamValue)
 In YAMGovernanceToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION dstRepOld = checkpoints[dstRep][dstRepNum - 1].votes
 In YAMDelegate.safe32, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(n < 2 ** 32,errorMessage)
 In YAMToken.fragmentToYam, it can be over/underflowed. check your logic: RETURN _fragmentToYam(value)
 In YAMToken._writeCheckpoint, it can be over/underflowed. check your logic: IF nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
 In YAMToken.yamToFragment, it can be over/underflowed. check your logic: RETURN _yamToFragment(yam)
 In YAMToken.transfer, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAMTokenStorage.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAMToken._mint, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(yamsScalingFactor <= _maxScalingFactor(),max scaling factor too low)
 In YAMToken.getCurrentVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMDelegate._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION dstRepOld = checkpoints[dstRep][dstRepNum - 1].votes
 In YAMTokenStorage.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAMGovernanceToken.delegateBySig, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(nonce == nonces[signatory] ++,YAM::delegateBySig: invalid nonce)
 In YAMToken.balanceOf, it can be over/underflowed. check your logic: RETURN _yamToFragment(_yamBalances[who])
 In YAM.getPriorVotes, it can be over/underflowed. check your logic: EXPRESSION upper = center - 1
 In YAMToken.rebase, it can be over/underflowed. check your logic: EXPRESSION yamsScalingFactor = _maxScalingFactor()
 In YAMDelegate.rebase, it can be over/underflowed. check your logic: EXPRESSION totalSupply = _yamToFragment(initSupply)
 In YAMGovernanceToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAMDelegate.rebase, it can be over/underflowed. check your logic: IF newScalingFactor < _maxScalingFactor()
 In YAM._delegate, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(currentDelegate,delegatee,delegatorBalance)
 In YAMToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAMGovernanceToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(dstRep,dstRepNum,dstRepOld,dstRepNew)
 In YAMGovernanceToken._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION numCheckpoints[delegatee] = nCheckpoints + 1
 In YAMGovernanceToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION srcRepOld = checkpoints[srcRep][srcRepNum - 1].votes
 In YAMDelegate._mint, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(yamsScalingFactor <= _maxScalingFactor(),max scaling factor too low)
 In YAM._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION srcRepOld = checkpoints[srcRep][srcRepNum - 1].votes
 In YAMTokenInterface.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAM._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION checkpoints[delegatee][nCheckpoints - 1].votes = newVotes
 In YAMDelegate.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE upper = nCheckpoints - 1
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In YAM._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(srcRep,srcRepNum,srcRepOld,srcRepNew)
 In YAMTokenInterface.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAM.delegateBySig, it can be over/underflowed. check your logic: RETURN _delegate(signatory,delegatee)
 In YAMToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(dstRep,dstRepNum,dstRepOld,dstRepNew)
 In YAMDelegate.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[from],_delegates[to],yamValue)
 In YAMDelegate._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION checkpoints[delegatee][nCheckpoints - 1].votes = newVotes
 In YAM._writeCheckpoint, it can be over/underflowed. check your logic: IF nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
 In YAMDelegate.getPriorVotes, it can be over/underflowed. check your logic: IF checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber
 In YAMDelegate.getCurrentVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMToken._writeCheckpoint, it can be over/underflowed. check your logic: NEW VARIABLE blockNumber = safe32(block.number,YAM::_writeCheckpoint: block number exceeds 32 bits)
 In YAM.initialize, it can be over/underflowed. check your logic: EXPRESSION initSupply = _fragmentToYam(initTotalSupply_)
 In YAMDelegate.maxScalingFactor, it can be over/underflowed. check your logic: RETURN _maxScalingFactor()
 In YAM._mint, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(yamsScalingFactor <= _maxScalingFactor(),max scaling factor too low)
 In YAM._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(dstRep,dstRepNum,dstRepOld,dstRepNew)
 In YAM.maxScalingFactor, it can be over/underflowed. check your logic: RETURN _maxScalingFactor()
 In YAMGovernanceToken._writeCheckpoint, it can be over/underflowed. check your logic: IF nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
 In YAMToken.getPriorVotes, it can be over/underflowed. check your logic: IF checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber
 In YAMDelegate.getPriorVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMGovernanceToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAMGovernanceToken.safe32, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(n < 2 ** 32,errorMessage)
 In YAMToken.delegateBySig, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(nonce == nonces[signatory] ++,YAM::delegateBySig: invalid nonce)
 In YAMToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAMGovernanceToken._delegate, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(currentDelegate,delegatee,delegatorBalance)
 In YAMToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,amount)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In YAMDelegate.delegateBySig, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(nonce == nonces[signatory] ++,YAM::delegateBySig: invalid nonce)
 In YAM._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION numCheckpoints[delegatee] = nCheckpoints + 1
 In YAMGovernanceToken.getPriorVotes, it can be over/underflowed. check your logic: EXPRESSION upper = center - 1
 In YAMDelegate._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION numCheckpoints[delegatee] = nCheckpoints + 1
 In YAM.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE center = upper - (upper - lower) / 2
 In YAMGovernanceToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(srcRep,srcRepNum,srcRepOld,srcRepNew)
 In YAMToken.getPriorVotes, it can be over/underflowed. check your logic: EXPRESSION upper = center - 1
 In YAMToken.safe32, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(n < 2 ** 32,errorMessage)
 In YAMGovernanceToken.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE center = upper - (upper - lower) / 2
 In YAM.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE upper = nCheckpoints - 1
 In YAM._maxScalingFactor, it can be over/underflowed. check your logic: RETURN uint256(- 1) / initSupply
 In YAMGovernanceToken.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE upper = nCheckpoints - 1
 In YAM.yamToFragment, it can be over/underflowed. check your logic: RETURN _yamToFragment(yam)
 In YAMDelegate.transferFrom, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAMToken.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE upper = nCheckpoints - 1
 In YAM._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],amount)
 In YAMDelegate.transfer, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAMToken.getPriorVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMDelegate.fragmentToYam, it can be over/underflowed. check your logic: RETURN _fragmentToYam(value)
 In YAMDelegate.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE center = upper - (upper - lower) / 2
 In YAM.delegateBySig, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(nonce == nonces[signatory] ++,YAM::delegateBySig: invalid nonce)
 In YAMToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION dstRepOld = checkpoints[dstRep][dstRepNum - 1].votes
 In YAMToken._maxScalingFactor, it can be over/underflowed. check your logic: RETURN uint256(- 1) / initSupply
 In YAM.transferFrom, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAMToken._mint, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(amount)
 In YAM.getPriorVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAM._writeCheckpoint, it can be over/underflowed. check your logic: NEW VARIABLE blockNumber = safe32(block.number,YAM::_writeCheckpoint: block number exceeds 32 bits)
 In YAMDelegate.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAMToken._delegate, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(currentDelegate,delegatee,delegatorBalance)
 In YAMToken._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION checkpoints[delegatee][nCheckpoints - 1].votes = newVotes
 In YAMDelegate._writeCheckpoint, it can be over/underflowed. check your logic: IF nCheckpoints > 0 && checkpoints[delegatee][nCheckpoints - 1].fromBlock == blockNumber
 In YAMToken._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION numCheckpoints[delegatee] = nCheckpoints + 1
 In YAM.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[from],_delegates[to],yamValue)
 In YAMToken.delegate, it can be over/underflowed. check your logic: RETURN _delegate(msg.sender,delegatee)
 In YAMDelegate._mint, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(amount)
 In YAMGovernanceToken._writeCheckpoint, it can be over/underflowed. check your logic: EXPRESSION checkpoints[delegatee][nCheckpoints - 1].votes = newVotes
 In YAMDelegate._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION srcRepOld = checkpoints[srcRep][srcRepNum - 1].votes
 In YAM._mint, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(amount)
 In YAMToken._mint, it can be over/underflowed. check your logic: NEW VARIABLE scaledAmount = _yamToFragment(amount)
 In YAMDelegate.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In YAMDelegate._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],yamValue)
 In YAMDelegate._mint, it can be over/underflowed. check your logic: NEW VARIABLE scaledAmount = _yamToFragment(amount)
 In YAMToken.delegateBySig, it can be over/underflowed. check your logic: RETURN _delegate(signatory,delegatee)
 In YAMToken.rebase, it can be over/underflowed. check your logic: IF newScalingFactor < _maxScalingFactor()
 In YAMDelegate.initialize, it can be over/underflowed. check your logic: EXPRESSION initSupply = _fragmentToYam(initTotalSupply_)
 In YAMDelegate.delegate, it can be over/underflowed. check your logic: RETURN _delegate(msg.sender,delegatee)
 In YAMToken.getPriorVotes, it can be over/underflowed. check your logic: NEW VARIABLE center = upper - (upper - lower) / 2
 In YAMGovernanceToken._writeCheckpoint, it can be over/underflowed. check your logic: NEW VARIABLE blockNumber = safe32(block.number,YAM::_writeCheckpoint: block number exceeds 32 bits)
 In YAMDelegate.yamToFragment, it can be over/underflowed. check your logic: RETURN _yamToFragment(yam)
 In YAMToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[from],_delegates[to],yamValue)
 In YAMDelegate.balanceOf, it can be over/underflowed. check your logic: RETURN _yamToFragment(_yamBalances[who])
 In YAMToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[msg.sender],_delegates[to],yamValue)
 In YAMDelegate._maxScalingFactor, it can be over/underflowed. check your logic: RETURN uint256(- 1) / initSupply
 In YAM.delegate, it can be over/underflowed. check your logic: RETURN _delegate(msg.sender,delegatee)
 In YAM.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT internalDecimals = 10 ** 24
 In YAMToken.transferFrom, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAMDelegate.delegateBySig, it can be over/underflowed. check your logic: RETURN _delegate(signatory,delegatee)
 In YAMDelegate.rebase, it can be over/underflowed. check your logic: EXPRESSION yamsScalingFactor = _maxScalingFactor()
 In YAMDelegate.transfer, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[msg.sender],_delegates[to],yamValue)
 In YAMDelegate.getPriorVotes, it can be over/underflowed. check your logic: EXPRESSION upper = center - 1
 In YAMToken.maxScalingFactor, it can be over/underflowed. check your logic: RETURN _maxScalingFactor()
 In YAMDelegate._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(srcRep,srcRepNum,srcRepOld,srcRepNew)
 In YAM.safe32, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(n < 2 ** 32,errorMessage)
 In YAMToken.rebase, it can be over/underflowed. check your logic: EXPRESSION totalSupply = _yamToFragment(initSupply)
 In YAM.fragmentToYam, it can be over/underflowed. check your logic: RETURN _fragmentToYam(value)
 In YAM.transfer, it can be over/underflowed. check your logic: NEW VARIABLE yamValue = _fragmentToYam(value)
 In YAM.rebase, it can be over/underflowed. check your logic: IF newScalingFactor < _maxScalingFactor()
 In YAM.transfer, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(_delegates[msg.sender],_delegates[to],yamValue)
 In YAMToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION srcRepOld = checkpoints[srcRep][srcRepNum - 1].votes
 In YAMDelegate._delegate, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(currentDelegate,delegatee,delegatorBalance)
 In YAMDelegate.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAM._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION dstRepOld = checkpoints[dstRep][dstRepNum - 1].votes
 In YAMGovernanceToken.getPriorVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMDelegate.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,amount)
 In YAM.getPriorVotes, it can be over/underflowed. check your logic: IF checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber
 In YAMDelegate._writeCheckpoint, it can be over/underflowed. check your logic: NEW VARIABLE blockNumber = safe32(block.number,YAM::_writeCheckpoint: block number exceeds 32 bits)
 In YAM.balanceOf, it can be over/underflowed. check your logic: RETURN _yamToFragment(_yamBalances[who])
 In YAM._mint, it can be over/underflowed. check your logic: NEW VARIABLE scaledAmount = _yamToFragment(amount)
 In YAMGovernanceToken.delegate, it can be over/underflowed. check your logic: RETURN _delegate(msg.sender,delegatee)
 In YAM.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT BASE = 10 ** 18
 In YAMToken._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(srcRep,srcRepNum,srcRepOld,srcRepNew)
 In YAM.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,amount)
 In YAMToken._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],amount)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In YAM.getCurrentVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAMGovernanceToken.getCurrentVotes, it can be over/underflowed. check your logic: RETURN checkpoints[account][nCheckpoints - 1].votes
 In YAM.rebase, it can be over/underflowed. check your logic: EXPRESSION yamsScalingFactor = _maxScalingFactor()
 In YAM.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In YAMDelegate._mint, it can be over/underflowed. check your logic: EXPRESSION _moveDelegates(address(0),_delegates[to],amount)
 In YAMGovernanceToken.delegateBySig, it can be over/underflowed. check your logic: RETURN _delegate(signatory,delegatee)
 In YAMGovernanceToken.getPriorVotes, it can be over/underflowed. check your logic: IF checkpoints[account][nCheckpoints - 1].fromBlock <= blockNumber
 In YAM.rebase, it can be over/underflowed. check your logic: EXPRESSION totalSupply = _yamToFragment(initSupply)
 In YAMDelegate._moveDelegates, it can be over/underflowed. check your logic: EXPRESSION _writeCheckpoint(dstRep,dstRepNum,dstRepOld,dstRepNew)
 In YAMToken.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 
line_number: 1017
line_number: 1102
line_number: 1122

Filename: 0x6925b397ed7394573bb68bac9d9e1ff39e976d62_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
KugulaToken.constructor() (0x6925b397ed7394573bb68bac9d9e1ff39e976d62_integerOverflow.sol#184-187) uses literals with too many digits: 10000000000000000000000000 recommended suffix: ether
	- totalSupply_ = 10000000000000000000000000 (0x6925b397ed7394573bb68bac9d9e1ff39e976d62_integerOverflow.sol#185)
 check: over-underflow
impact: Low
confidence: Low
description
In StandardToken.transferFrom, it can be over/underflowed. check your logic: RETURN burnFrom(_from,_value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In StandardToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MAX_UINT = 2 ** 256 - 1
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In KugulaToken.transferFrom, it can be over/underflowed. check your logic: RETURN burnFrom(_from,_value)
 In BasicToken.transfer, it can be over/underflowed. check your logic: RETURN burn(_value)
 In KugulaToken.transfer, it can be over/underflowed. check your logic: RETURN burn(_value)
 In StandardToken.transfer, it can be over/underflowed. check your logic: RETURN burn(_value)
 
line_number: 65
line_number: 67
line_number: 69
line_number: 86
line_number: 118
line_number: 120
line_number: 136
line_number: 158
line_number: 169

Filename: 0x6a61da5e3e26e38029f36282331f2e6b2624b202_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In UniswapERC20.getInputPrice, it can be over/underflowed. check your logic: RETURN getInputPrice(amountSold,inputReserve,outputReserve)
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE amountSold = newInputReserve - oldInputReserve
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE amountBought = getInputPrice(amountSold,oldInputReserve,currentOutputReserve)
 In UniswapERC20.swapBForA, it can be over/underflowed. check your logic: EXPRESSION (amountSold,amountBought) = swap(tokenB,tokenA,recipient)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In UniswapERC20.swapAForB, it can be over/underflowed. check your logic: EXPRESSION (amountSold,amountBought) = swap(tokenA,tokenB,recipient)
 In UniswapERC20.addLiquidity, it can be over/underflowed. check your logic: NEW VARIABLE amountA = newReserveA - oldReserveA
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE newOutputReserve = currentOutputReserve - amountBought
 In UniswapERC20.addLiquidity, it can be over/underflowed. check your logic: NEW VARIABLE amountB = newReserveB - oldReserveB
 
line_number: 63
line_number: 71
line_number: 74
line_number: 76
line_number: 89
line_number: 91
line_number: 256

Filename: 0x721e0193cb5986cddc0142726bea3aeb742a27b2_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
MxnToken.slitherConstructorVariables() (0x721e0193cb5986cddc0142726bea3aeb742a27b2_integerOverflow.sol#441-452) uses literals with too many digits: 2000000000000000000000000000 recommended suffix: ether
	- INITIAL_SUPPLY = 2000000000000000000000000000 (0x721e0193cb5986cddc0142726bea3aeb742a27b2_integerOverflow.sol#445)
 check: over-underflow
impact: Low
confidence: Low
description
In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = _a * _b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In MxnToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = _a + _b
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In MxnToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In MxnToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In MxnToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN _a - _b
 
line_number: 103
line_number: 174
line_number: 255

Filename: 0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
UniswapV2Pair.swap(uint256,uint256,address,bytes) (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#359-387) uses literals with too many digits: 2 recommended suffix: gwei
	- require(bool,string)(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),UniswapV2: K) (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#382)
 UQ112x112.slitherConstructorConstantVariables() (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#491-504) uses literals with too many digits: 112 recommended suffix: ether
	- Q112 = 2 ** 112 (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#492)
 UniswapV2Pair.slitherConstructorConstantVariables() (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#211-401) uses literals with too many digits: 3 recommended suffix: gwei
	- MINIMUM_LIQUIDITY = 10 ** 3 (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#215)
 UniswapV2Pair._update(uint256,uint256,uint112,uint112) (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#273-286) uses literals with too many digits: 32 recommended suffix: ether
	- blockTimestamp = uint32(block.timestamp % 2 ** 32) (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#275)
 UniswapV2Factory.createPair(address,address) (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#420-435) uses literals with too many digits: 60806040526001600c5534801561001557600080fd5b5060004690506040518080613b6460529139605201905060405180910390206040518060400160405280600a81526020017f556e697377617020563200000000000000000000000000000000000000000000815250805190602001206040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250805190602001208330604051602001808681526020018581526020018481526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200195505050505050604051602081830303815290604052805190602001206003819055505033600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506139ef806101756000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80636a627842116100f9578063ba9a7a5611610097578063d21220a711610071578063d21220a7146108c4578063d505accf1461090e578063dd62ed3e146109a7578063fff6cae914610a1f576101a9565b8063ba9a7a5614610818578063bc25cf7714610836578063c45a01551461087a576101a9565b80637ecebe00116100d35780637ecebe001461067857806389afcb44146106d057806395d89b411461072f578063a9059cbb146107b2576101a9565b80636a627842146105aa57806370a08231146106025780637464fc3d1461065a576101a9565b806323b872dd116101665780633644e515116101405780633644e515146104ec578063485cc9551461050a5780635909c0d51461056e5780635a3d54931461058c576101a9565b806323b872dd1461042457806330adf81f146104aa578063313ce567146104c8576101a9565b8063022c0d9f146101ae57806306fdde031461025b5780630902f1ac146102de578063095ea7b3146103565780630dfe1681146103bc57806318160ddd14610406575b600080fd5b610259600480360360808110156101c457600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019064010000000081111561021557600080fd5b82018360208201111561022757600080fd5b8035906020019184600183028401116401000000008311171561024957600080fd5b9091929391929390505050610a29565b005b610263611216565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156102a3578082015181840152602081019050610288565b50505050905090810190601f1680156102d05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6102e661124f565b60405180846dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152602001836dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1681526020018263ffffffff1663ffffffff168152602001935050505060405180910390f35b6103a26004803603604081101561036c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506112ac565b604051808215151515815260200191505060405180910390f35b6103c46112c3565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61040e6112e9565b6040518082815260200191505060405180910390f35b6104906004803603606081101561043a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506112ef565b604051808215151515815260200191505060405180910390f35b6104b26114ba565b6040518082815260200191505060405180910390f35b6104d06114e1565b604051808260ff1660ff16815260200191505060405180910390f35b6104f46114e6565b6040518082815260200191505060405180910390f35b61056c6004803603604081101561052057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506114ec565b005b610576611635565b6040518082815260200191505060405180910390f35b61059461163b565b6040518082815260200191505060405180910390f35b6105ec600480360360208110156105c057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611641565b6040518082815260200191505060405180910390f35b6106446004803603602081101561061857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611af2565b6040518082815260200191505060405180910390f35b610662611b0a565b6040518082815260200191505060405180910390f35b6106ba6004803603602081101561068e57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611b10565b6040518082815260200191505060405180910390f35b610712600480360360208110156106e657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611b28565b604051808381526020018281526020019250505060405180910390f35b610737612115565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561077757808201518184015260208101905061075c565b50505050905090810190601f1680156107a45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6107fe600480360360408110156107c857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061214e565b604051808215151515815260200191505060405180910390f35b610820612165565b6040518082815260200191505060405180910390f35b6108786004803603602081101561084c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061216b565b005b610882612446565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6108cc61246c565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6109a5600480360360e081101561092457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190929190803560ff1690602001909291908035906020019092919080359060200190929190505050612492565b005b610a09600480360360408110156109bd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506127d6565b6040518082815260200191505060405180910390f35b610a276127fb565b005b6001600c5414610aa1576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f556e697377617056323a204c4f434b454400000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000851180610ab85750600084115b610b0d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260258152602001806139016025913960400191505060405180910390fd5b600080610b1861124f565b5091509150816dffffffffffffffffffffffffffff1687108015610b4b5750806dffffffffffffffffffffffffffff1686105b610ba0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602181526020018061394a6021913960400191505060405180910390fd5b6000806000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614158015610c5957508073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614155b610ccb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260158152602001807f556e697377617056323a20494e56414c49445f544f000000000000000000000081525060200191505060405180910390fd5b60008b1115610ce057610cdf828a8d612a7b565b5b60008a1115610cf557610cf4818a8c612a7b565b5b6000888890501115610ddd578873ffffffffffffffffffffffffffffffffffffffff166310d1e85c338d8d8c8c6040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b158015610dc457600080fd5b505af1158015610dd8573d6000803e3d6000fd5b505050505b8173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610e5a57600080fd5b505afa158015610e6e573d6000803e3d6000fd5b505050506040513d6020811015610e8457600080fd5b810190808051906020019092919050505093508073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610f1457600080fd5b505afa158015610f28573d6000803e3d6000fd5b505050506040513d6020811015610f3e57600080fd5b810190808051906020019092919050505092505050600089856dffffffffffffffffffffffffffff16038311610f75576000610f8b565b89856dffffffffffffffffffffffffffff160383035b9050600089856dffffffffffffffffffffffffffff16038311610faf576000610fc5565b89856dffffffffffffffffffffffffffff160383035b90506000821180610fd65750600081115b61102b576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260248152602001806139266024913960400191505060405180910390fd5b6000611067611044600385612cc890919063ffffffff16565b6110596103e888612cc890919063ffffffff16565b612d5d90919063ffffffff16565b905060006110a5611082600385612cc890919063ffffffff16565b6110976103e888612cc890919063ffffffff16565b612d5d90919063ffffffff16565b90506110ef620f42406110e1896dffffffffffffffffffffffffffff168b6dffffffffffffffffffffffffffff16612cc890919063ffffffff16565b612cc890919063ffffffff16565b6111028284612cc890919063ffffffff16565b1015611176576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600c8152602001807f556e697377617056323a204b000000000000000000000000000000000000000081525060200191505060405180910390fd5b505061118484848888612d65565b8873ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d82284848f8f6040518085815260200184815260200183815260200182815260200194505050505060405180910390a35050505050506001600c819055505050505050565b6040518060400160405280600a81526020017f556e69737761702056320000000000000000000000000000000000000000000081525081565b6000806000600860009054906101000a90046dffffffffffffffffffffffffffff1692506008600e9054906101000a90046dffffffffffffffffffffffffffff1691506008601c9054906101000a900463ffffffff169050909192565b60006112b93384846130e3565b6001905092915050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054146114a45761142382600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d5d90919063ffffffff16565b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b6114af8484846131ce565b600190509392505050565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c960001b81565b601281565b60035481565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146115af576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f556e697377617056323a20464f5242494444454e00000000000000000000000081525060200191505060405180910390fd5b81600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60095481565b600a5481565b60006001600c54146116bb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f556e697377617056323a204c4f434b454400000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000806116ce61124f565b50915091506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561177457600080fd5b505afa158015611788573d6000803e3d6000fd5b505050506040513d602081101561179e57600080fd5b810190808051906020019092919050505090506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561185257600080fd5b505afa158015611866573d6000803e3d6000fd5b505050506040513d602081101561187c57600080fd5b8101908080519060200190929190505050905060006118b4856dffffffffffffffffffffffffffff1684612d5d90919063ffffffff16565b905060006118db856dffffffffffffffffffffffffffff1684612d5d90919063ffffffff16565b905060006118e98787613362565b9050600080549050600081141561193d576119296103e861191b6119168688612cc890919063ffffffff16565b613543565b612d5d90919063ffffffff16565b985061193860006103e86135a5565b6119a0565b61199d886dffffffffffffffffffffffffffff166119648387612cc890919063ffffffff16565b8161196b57fe5b04886dffffffffffffffffffffffffffff166119908487612cc890919063ffffffff16565b8161199757fe5b046136bf565b98505b600089116119f9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260288152602001806139936028913960400191505060405180910390fd5b611a038a8a6135a5565b611a0f86868a8a612d65565b8115611a8757611a806008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16612cc890919063ffffffff16565b600b819055505b3373ffffffffffffffffffffffffffffffffffffffff167f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f8585604051808381526020018281526020019250505060405180910390a250505050505050506001600c81905550919050565b60016020528060005260406000206000915090505481565b600b5481565b60046020528060005260406000206000915090505481565b6000806001600c5414611ba3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f556e697377617056323a204c4f434b454400000000000000000000000000000081525060200191505060405180910390fd5b6000600c81905550600080611bb661124f565b50915091506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611c8857600080fd5b505afa158015611c9c573d6000803e3d6000fd5b505050506040513d6020811015611cb257600080fd5b8101908080519060200190929190505050905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611d4457600080fd5b505afa158015611d58573d6000803e3d6000fd5b505050506040513d6020811015611d6e57600080fd5b810190808051906020019092919050505090506000600160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506000611dd18888613362565b905060008054905080611ded8685612cc890919063ffffffff16565b81611df457fe5b049a5080611e0b8585612cc890919063ffffffff16565b81611e1257fe5b04995060008b118015611e25575060008a115b611e7a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602881526020018061396b6028913960400191505060405180910390fd5b611e8430846136d8565b611e8f878d8d612a7b565b611e9a868d8c612a7b565b8673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611f1757600080fd5b505afa158015611f2b573d6000803e3d6000fd5b505050506040513d6020811015611f4157600080fd5b810190808051906020019092919050505094508573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611fd157600080fd5b505afa158015611fe5573d6000803e3d6000fd5b505050506040513d6020811015611ffb57600080fd5b8101908080519060200190929190505050935061201a85858b8b612d65565b81156120925761208b6008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16612cc890919063ffffffff16565b600b819055505b8b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d819364968d8d604051808381526020018281526020019250505060405180910390a35050505050505050506001600c81905550915091565b6040518060400160405280600681526020017f554e492d5632000000000000000000000000000000000000000000000000000081525081565b600061215b3384846131ce565b6001905092915050565b6103e881565b6001600c54146121e3576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f556e697377617056323a204c4f434b454400000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506123398284612334600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156122eb57600080fd5b505afa1580156122ff573d6000803e3d6000fd5b505050506040513d602081101561231557600080fd5b8101908080519060200190929190505050612d5d90919063ffffffff16565b612a7b565b61243981846124346008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156123eb57600080fd5b505afa1580156123ff573d6000803e3d6000fd5b505050506040513d602081101561241557600080fd5b8101908080519060200190929190505050612d5d90919063ffffffff16565b612a7b565b50506001600c8190555050565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b42841015612508576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f556e697377617056323a2045585049524544000000000000000000000000000081525060200191505060405180910390fd5b60006003547f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c960001b898989600460008e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000815480929190600101919050558a604051602001808781526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815260200182815260200196505050505050506040516020818303038152906040528051906020012060405160200180807f190100000000000000000000000000000000000000000000000000000000000081525060020183815260200182815260200192505050604051602081830303815290604052805190602001209050600060018286868660405160008152602001604052604051808581526020018460ff1660ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa1580156126da573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415801561274e57508873ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b6127c0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601c8152602001807f556e697377617056323a20494e56414c49445f5349474e41545552450000000081525060200191505060405180910390fd5b6127cb8989896130e3565b505050505050505050565b6002602052816000526040600020602052806000526040600020600091509150505481565b6001600c5414612873576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f556e697377617056323a204c4f434b454400000000000000000000000000000081525060200191505060405180910390fd5b6000600c81905550612a71600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561291d57600080fd5b505afa158015612931573d6000803e3d6000fd5b505050506040513d602081101561294757600080fd5b8101908080519060200190929190505050600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b1580156129f757600080fd5b505afa158015612a0b573d6000803e3d6000fd5b505050506040513d6020811015612a2157600080fd5b8101908080519060200190929190505050600860009054906101000a90046dffffffffffffffffffffffffffff166008600e9054906101000a90046dffffffffffffffffffffffffffff16612d65565b6001600c81905550565b600060608473ffffffffffffffffffffffffffffffffffffffff166040518060400160405280601981526020017f7472616e7366657228616464726573732c75696e743235362900000000000000815250805190602001208585604051602401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310612ba85780518252602082019150602081019050602083039250612b85565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612c0a576040519150601f19603f3d011682016040523d82523d6000602084013e612c0f565b606091505b5091509150818015612c4f5750600081511480612c4e5750808060200190516020811015612c3c57600080fd5b81019080805190602001909291905050505b5b612cc1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f556e697377617056323a205452414e534645525f4641494c454400000000000081525060200191505060405180910390fd5b5050505050565b600080821480612ce55750828283850292508281612ce257fe5b04145b612d57576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6d756c2d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b600092915050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6dffffffffffffffffffffffffffff168411158015612dd557507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6dffffffffffffffffffffffffffff168311155b612e47576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f556e697377617056323a204f564552464c4f570000000000000000000000000081525060200191505060405180910390fd5b60006401000000004281612e5757fe5b06905060006008601c9054906101000a900463ffffffff168203905060008163ffffffff16118015612e9a57506000846dffffffffffffffffffffffffffff1614155b8015612eb757506000836dffffffffffffffffffffffffffff1614155b15612f99578063ffffffff16612efc85612ed0866137f2565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1661381d90919063ffffffff16565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16026009600082825401925050819055508063ffffffff16612f6a84612f3e876137f2565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1661381d90919063ffffffff16565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602600a600082825401925050819055505b85600860006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff160217905550846008600e6101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff160217905550816008601c6101000a81548163ffffffff021916908363ffffffff1602179055507f1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1600860009054906101000a90046dffffffffffffffffffffffffffff166008600e9054906101000a90046dffffffffffffffffffffffffffff1660405180836dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152602001826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1681526020019250505060405180910390a1505050505050565b80600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040518082815260200191505060405180910390a3505050565b61322081600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d5d90919063ffffffff16565b600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506132b581600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461387d90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a3505050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663017e7e586040518163ffffffff1660e01b815260040160206040518083038186803b1580156133cd57600080fd5b505afa1580156133e1573d6000803e3d6000fd5b505050506040513d60208110156133f757600080fd5b81019080805190602001909291905050509050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141591506000600b5490508215613529576000811461352457600061348f61348a866dffffffffffffffffffffffffffff16886dffffffffffffffffffffffffffff16612cc890919063ffffffff16565b613543565b9050600061349c83613543565b9050808211156135215760006134cf6134be8385612d5d90919063ffffffff16565b600054612cc890919063ffffffff16565b905060006134f9836134eb600587612cc890919063ffffffff16565b61387d90919063ffffffff16565b9050600081838161350657fe5b049050600081111561351d5761351c87826135a5565b5b5050505b50505b61353b565b6000811461353a576000600b819055505b5b505092915050565b6000600382111561359257819050600060016002848161355f57fe5b040190505b8181101561358c5780915060028182858161357b57fe5b04018161358457fe5b049050613564565b506135a0565b6000821461359f57600190505b5b919050565b6135ba8160005461387d90919063ffffffff16565b60008190555061361281600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461387d90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35050565b60008183106136ce57816136d0565b825b905092915050565b61372a81600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d5d90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061378281600054612d5d90919063ffffffff16565b600081905550600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35050565b60006e010000000000000000000000000000826dffffffffffffffffffffffffffff16029050919050565b6000816dffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168161387457fe5b04905092915050565b60008282840191508110156138fa576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b9291505056fe556e697377617056323a20494e53554646494349454e545f4f55545055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f494e5055545f414d4f554e54556e697377617056323a20494e53554646494349454e545f4c4951554944495459556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4255524e4544556e697377617056323a20494e53554646494349454e545f4c49515549444954595f4d494e544544a265627a7a72315820a73645a8a6934b1639a0704e8202f408d6b458a32420d133894d9aa3a49ff57a64736f6c63430005100032454950373132446f6d61696e28737472696e67206e616d652c737472696e672076657273696f6e2c75696e7432353620636861696e49642c6164647265737320766572696679696e67436f6e747261637429 recommended suffix: ether
	- bytecode = type(address)(UniswapV2Pair).creationCode (0x771ad2c58c747b428beacd389896650dd826d150_integerOverflow.sol#425)
 check: over-underflow
impact: Low
confidence: Low
description
In UniswapV2Pair.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(address(0),MINIMUM_LIQUIDITY)
 In UniswapV2Pair.transferFrom, it can be over/underflowed. check your logic: IF allowance[from][msg.sender] != uint256(- 1)
 In UniswapV2ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In UQ112x112.encode, it can be over/underflowed. check your logic: EXPRESSION z = uint224(y) * Q112
 In UniswapV2Pair.sync, it can be over/underflowed. check your logic: EXPRESSION _update(IERC20(token0).balanceOf(address(this)),IERC20(token1).balanceOf(address(this)),reserve0,reserve1)
 In UniswapV2Pair._update, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balance0 <= uint112(- 1) && balance1 <= uint112(- 1),UniswapV2: OVERFLOW)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((z = x + y) >= x,ds-math-add-overflow)
 In UniswapV2Pair.burn, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: IF balance1 > _reserve1 - amount1Out
 In UniswapV2Pair.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,liquidity)
 In UniswapV2Pair._update, it can be over/underflowed. check your logic: EXPRESSION price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed
 In UniswapV2Pair.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),UniswapV2: K)
 In UniswapV2ERC20.transferFrom, it can be over/underflowed. check your logic: IF allowance[from][msg.sender] != uint256(- 1)
 In Math.sqrt, it can be over/underflowed. check your logic: NEW VARIABLE x = y / 2 + 1
 In UQ112x112.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT Q112 = 2 ** 112
 In UniswapV2Pair.mint, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In UniswapV2Factory.createPair, it can be over/underflowed. check your logic: EXPRESSION allPairs.push(pair)
 In UniswapV2Pair._update, it can be over/underflowed. check your logic: NEW VARIABLE blockTimestamp = uint32(block.timestamp % 2 ** 32)
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: IF balance0 > _reserve0 - amount0Out
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(y == 0 || (z = x * y) / y == x,ds-math-mul-overflow)
 In UniswapV2Pair.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MINIMUM_LIQUIDITY = 10 ** 3
 In Math.sqrt, it can be over/underflowed. check your logic: EXPRESSION x = (y / x + x) / 2
 In UniswapV2Pair._update, it can be over/underflowed. check your logic: EXPRESSION price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed
 In UniswapV2ERC20.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In UniswapV2Pair.burn, it can be over/underflowed. check your logic: NEW VARIABLE feeOn = _mintFee(_reserve0,_reserve1)
 In UniswapV2Pair.mint, it can be over/underflowed. check your logic: NEW VARIABLE feeOn = _mintFee(_reserve0,_reserve1)
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: EXPRESSION amount0In = balance0 - (_reserve0 - amount0Out)
 In UniswapV2Pair._update, it can be over/underflowed. check your logic: NEW VARIABLE timeElapsed = blockTimestamp - blockTimestampLast
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: EXPRESSION amount1In = balance1 - (_reserve1 - amount1Out)
 In UniswapV2ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In UniswapV2Pair.swap, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In UniswapV2Pair._mintFee, it can be over/underflowed. check your logic: EXPRESSION _mint(feeTo,liquidity)
 In UniswapV2Pair.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In UniswapV2Pair.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 189

Filename: 0x786001c9c5CA6E502dEB8a8a72480d2147891f32_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
BetProtocolToken.slitherConstructorConstantVariables() (0x786001c9c5CA6E502dEB8a8a72480d2147891f32_integerOverflow.sol#493-508) uses literals with too many digits: 10000000000 recommended suffix: gwei
	- TOTAL_CAP = 10000000000 * 1000000000000000000 (0x786001c9c5CA6E502dEB8a8a72480d2147891f32_integerOverflow.sol#499)
 check: over-underflow
impact: Low
confidence: Low
description
In BetProtocolToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In BetProtocolToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In BetProtocolToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In BetProtocolToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In BetProtocolToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT TOTAL_CAP = 10000000000 * 1000000000000000000
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 
line_number: 209
line_number: 265
line_number: 309
line_number: 330

Filename: 0x7A11DC809Ec055AC4FdeF704a37Cd2Dc669B29AB_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
YUANUSDxIncentivizer.notifyRewardAmountAndDuration(uint256,uint256) (0x7A11DC809Ec055AC4FdeF704a37Cd2Dc669B29AB_integerOverflow.sol#834-863) uses literals with too many digits: 22 recommended suffix: ether
	- require(bool,string)(reward < uint256(- 1) / 10 ** 22,rewards too large, would lock) (0x7A11DC809Ec055AC4FdeF704a37Cd2Dc669B29AB_integerOverflow.sol#843)
 YUANUSDxIncentivizer.getReward() (0x7A11DC809Ec055AC4FdeF704a37Cd2Dc669B29AB_integerOverflow.sol#814-827) uses literals with too many digits: 18 recommended suffix: ether
	- trueReward = reward.mul(scalingFactor).div(10 ** 18) (0x7A11DC809Ec055AC4FdeF704a37Cd2Dc669B29AB_integerOverflow.sol#819)
 check: over-underflow
impact: Low
confidence: Low
description
In YUANUSDxIncentivizer.withdraw, it can be over/underflowed. check your logic: EXPRESSION super.withdraw(amount)
 In YUANUSDxIncentivizer.stake, it can be over/underflowed. check your logic: EXPRESSION super.stake(amount)
 In YUANUSDxIncentivizer.earned, it can be over/underflowed. check your logic: RETURN balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account])
 In YUANUSDxIncentivizer.stake, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In YUANUSDxIncentivizer.withdraw, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In YUANUSDxIncentivizer.exit, it can be over/underflowed. check your logic: EXPRESSION getReward()
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In YUANUSDxIncentivizer.notifyRewardAmountAndDuration, it can be over/underflowed. check your logic: EXPRESSION updateReward(address(0))
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + (((a % 2) + (b % 2)) / 2)
 In YUANUSDxIncentivizer.getReward, it can be over/underflowed. check your logic: NEW VARIABLE trueReward = reward.mul(scalingFactor).div(10 ** 18)
 In YUANUSDxIncentivizer.getReward, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In YUANUSDxIncentivizer.exit, it can be over/underflowed. check your logic: EXPRESSION withdraw(balanceOf(msg.sender))
 In YUANUSDxIncentivizer.notifyRewardAmountAndDuration, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(reward < uint256(- 1) / 10 ** 22,rewards too large, would lock)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 
line_number: 712
line_number: 714
line_number: 720
line_number: 722
line_number: 849
line_number: 859

Filename: 0x7ed0226b939f43efe0fc37537566cb642cb1da59_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In IterableMap.remove, it can be over/underflowed. check your logic: EXPRESSION self.indexes.length -= 1
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In IterableMap.remove, it can be over/underflowed. check your logic: EXPRESSION self.indexes[deleteIndex - 1] = self.indexes[self.indexes.length - 1]
 In IterableMap.insert, it can be over/underflowed. check your logic: EXPRESSION self.indexes.push(_address)
 In IterableMap.remove, it can be over/underflowed. check your logic: EXPRESSION self.mapToIndex[self.indexes[deleteIndex - 1]] = deleteIndex
 
line_number: 298

Filename: 0x7ee78165525e6788b46c405e59baa957f25ebca8_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In NISToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ERC20Pausable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In ERC20Pausable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In NISToken.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In ERC20Pausable.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In NISToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In NISToken.decreaseAllowance, it can be over/underflowed. check your logic: RETURN super.decreaseAllowance(spender,subtractedValue)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 In ERC20Pausable.increaseAllowance, it can be over/underflowed. check your logic: RETURN super.increaseAllowance(spender,addedValue)
 In NISToken.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,totalSupply)
 In NISToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In ERC20Pausable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In NISToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(to,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In NISToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(from,to,value)
 
line_number: 182
line_number: 202
line_number: 221

Filename: 0x801b78222c990fd44c9e21a922f90799c39597bc_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In Ether5.withdrawIncome, it can be over/underflowed. check your logic: EXPRESSION settleIncome(_playerAddress,_amountLeft)
 In Ether5.getPlayerInfo, it can be over/underflowed. check your logic: EXPRESSION remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In Ether5.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Ether5.fallback, it can be over/underflowed. check your logic: EXPRESSION playGame(address(0x0))
 In Ether5.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,temp)
 In Ether5.constructor, it can be over/underflowed. check your logic: EXPRESSION round[1].endTime = now + poolTime
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Ether5.settleIncome, it can be over/underflowed. check your logic: IF now > player[_playerAddress].lastSettledTime + payoutPeriod
 In Ether5.referralBonusTransferDirect, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Ether5.startNewRound, it can be over/underflowed. check your logic: EXPRESSION _roundID ++
 In Ether5.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In Ether5.playGame, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDirect(msg.sender,amount.mul(20).div(100))
 In Ether5.referralBonusTransferDirect, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In Ether5.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,_dailyIncome.mul(remainingTimeForPayout))
 In Ether5.withdrawIncome, it can be over/underflowed. check your logic: NEW VARIABLE _earnings = player[_playerAddress].dailyIncome + player[_playerAddress].directReferralIncome + player[_playerAddress].roiReferralIncome
 In Ether5.getPlayerInfo, it can be over/underflowed. check your logic: IF player[_playerAddress].lastSettledTime + payoutPeriod >= now
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In Ether5.startNewRound, it can be over/underflowed. check your logic: EXPRESSION roundID ++
 
line_number: 649
line_number: 658
line_number: 665
line_number: 667

Filename: 0x8496a4a2678348e55c3ad1c45e53aadba5eb970c_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In Spin.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In Spin.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(account,amount)
 In Spin.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(_admin,_tokenInitAmount)
 
line_number: 180
line_number: 215

Filename: 0x84d40b26da4838eacec9ea1822db346e0f185086_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In MQMTOKEN.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In MQMTOKEN.claimTokens, it can be over/underflowed. check your logic: EXPRESSION transfer(receipent,lockedBalances[receipent])
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In MQMTOKEN.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In MQMTOKEN.claimTokens, it can be over/underflowed. check your logic: EXPRESSION i ++
 In MQMTOKEN.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In MQMTOKEN.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 
line_number: 164
line_number: 220
line_number: 264
line_number: 285
line_number: 371
line_number: 376
line_number: 378
line_number: 383
line_number: 385

Filename: 0x854893ea9c4c579522e06a2fbbb523e71120f716_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GovernanceGomics.slitherConstructorConstantVariables() (0x854893ea9c4c579522e06a2fbbb523e71120f716_integerOverflow.sol#188-462) uses literals with too many digits: 10000000000 recommended suffix: gwei
	- initialSupply = 10000000000 * (10 ** uint256(decimals)) (0x854893ea9c4c579522e06a2fbbb523e71120f716_integerOverflow.sol#192)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In GovernanceGomics.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 In GovernanceGomics.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT initialSupply = 10000000000 * (10 ** uint256(decimals))
 In GovernanceGomics.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i --
 In GovernanceGomics.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In GovernanceGomics.releaseLock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In GovernanceGomics.transferWithLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(_releaseTime,_value))
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GovernanceGomics.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(now + _afterTime,_value))
 In GovernanceGomics.balanceOf, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GovernanceGomics.lockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_holder,_amount,now + _afterTime)
 In GovernanceGomics.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In GovernanceGomics.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_who,_value)
 In GovernanceGomics.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GovernanceGomics.transfer, it can be over/underflowed. check your logic: EXPRESSION releaseLock(msg.sender)
 In GovernanceGomics.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GovernanceGomics.dropToken, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GovernanceGomics.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In GovernanceGomics.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 In GovernanceGomics.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GovernanceGomics.lock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(_releaseTime,_amount))
 In GovernanceGomics.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GovernanceGomics.mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(_to,_amount)
 In GovernanceGomics.transferFrom, it can be over/underflowed. check your logic: EXPRESSION releaseLock(_from)
 In GovernanceGomics.afterTime, it can be over/underflowed. check your logic: RETURN now + _value
 In GovernanceGomics.constructor, it can be over/underflowed. check your logic: EXPRESSION super._mint(msg.sender,initialSupply)
 In GovernanceGomics.dropToken, it can be over/underflowed. check your logic: EXPRESSION transfer(_receivers[i],_values[i])
 In GovernanceGomics.lockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(now + _afterTime,_amount))
 In GovernanceGomics.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_to,_value,now + _afterTime)
 In GovernanceGomics.unlock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In GovernanceGomics._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 118
line_number: 386
line_number: 398
line_number: 428
line_number: 445

Filename: 0x88af2c90fa9cf19cf08c8229fd8d9d2ddae47a72_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 156
line_number: 158

Filename: 0x8c152e933e7f20c3cca0ab7cad4d4bf1bc6e00e4_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In _0xLitecoin.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In _0xLitecoin.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In _0xLitecoin.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In _0xLitecoin.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In FreezeToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In FreezeToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In FreezeToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In FreezeToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In _0xLitecoin.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 
line_number: 174
line_number: 207
line_number: 224
line_number: 244

Filename: 0x8f6e944c3a6a875499d0360e8acf793effc410ff_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x8f6e944c3a6a875499d0360e8acf793effc410ff_integerOverflow.sol#2036-2074) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(staker.amount <= 0x100000000000000000000000000000000,staking amount is too high) (0x8f6e944c3a6a875499d0360e8acf793effc410ff_integerOverflow.sol#2063)
 GenesisProtocolLogic._stake(bytes32,uint256,uint256,address) (0x8f6e944c3a6a875499d0360e8acf793effc410ff_integerOverflow.sol#2036-2074) uses literals with too many digits: 0x100000000000000000000000000000000 recommended suffix: ether
	- require(bool,string)(proposal.totalStakes <= 0x100000000000000000000000000000000,total stakes is too high) (0x8f6e944c3a6a875499d0360e8acf793effc410ff_integerOverflow.sol#2064)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (_score(_proposalId) > confidenceThreshold) && (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply - amountBurned)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In ERC20Burnable.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In DAOToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceFrom = balanceOf(_user)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(totalSupplyHistory,curTotalSupply + _amount)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In ERC20Burnable.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In GenesisProtocolLogic.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION realResult = mul(realResult,tempRealBase)
 In GenesisProtocol.vote, it can be over/underflowed. check your logic: RETURN internalVote(_proposalId,voter,_vote,_amount)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: EXPRESSION j ++
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (_score(_proposalId) > confidenceThreshold) && (orgBoostedProposalsCnt[proposal.organizationId] < MAX_BOOSTED_PROPOSALS)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(curTotalSupply + _amount >= curTotalSupply)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE mid = (max + min + 1) / 2
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION orgBoostedProposalsCnt[proposal.organizationId] ++
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: IF (checkpoints.length == 0) || (checkpoints[checkpoints.length - 1].fromBlock < block.number)
 In GenesisProtocolLogic.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In Reputation.totalSupply, it can be over/underflowed. check your logic: RETURN totalSupplyAt(block.number)
 In GenesisProtocol.score, it can be over/underflowed. check your logic: RETURN _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[1]) >= proposal.currentBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.balanceOf, it can be over/underflowed. check your logic: RETURN balanceOfAt(_owner,block.number)
 In DAOToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In GenesisProtocolLogic.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE oldCheckPoint = checkpoints[checkpoints.length - 1]
 In RealMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE res = realA * realB
 In GenesisProtocol.executeBoosted, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(_execute(_proposalId),proposal need to expire)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = uint256(int256(averageDownstakesOfBoosted) + ((int256(proposal.stakes[NO]) - int256(averageDownstakesOfBoosted)) / int256(orgBoostedProposalsCnt[proposal.organizationId])))
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE previousBalanceTo = balanceOf(_user)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: IF _block >= checkpoints[checkpoints.length - 1].fromBlock
 In GenesisProtocol.execute, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In RealMath.pow, it can be over/underflowed. check your logic: EXPRESSION tempRealBase = mul(tempRealBase,tempRealBase)
 In GenesisProtocol.stakeWithSignature, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,staker)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION confidenceThreshold = threshold(proposal.paramsHash,proposal.organizationId)
 In Reputation.totalSupplyAt, it can be over/underflowed. check your logic: RETURN getValueAt(totalSupplyHistory,_blockNumber)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[0]) >= params.queuedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF _score(_proposalId) > confidenceThreshold
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.balanceOfAt, it can be over/underflowed. check your logic: RETURN getValueAt(balances[_owner],_blockNumber)
 In Reputation.burn, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION require(bool)(previousBalanceTo + _amount >= previousBalanceTo)
 In Reputation.getValueAt, it can be over/underflowed. check your logic: RETURN checkpoints[checkpoints.length - 1].value
 In Reputation.mint, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceTo + _amount)
 In GenesisProtocol.redeemDaoBounty, it can be over/underflowed. check your logic: EXPRESSION potentialAmount = (staker.amount4Bounty * proposal.daoBounty) / totalWinningStakes
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 In Reputation.getValueAt, it can be over/underflowed. check your logic: NEW VARIABLE max = checkpoints.length - 1
 In Reputation.getValueAt, it can be over/underflowed. check your logic: EXPRESSION max = mid - 1
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In DAOToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In ERC20Burnable.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In GenesisProtocolLogic.internalVote, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In Reputation.mint, it can be over/underflowed. check your logic: NEW VARIABLE curTotalSupply = totalSupply()
 In RealMath.fraction, it can be over/underflowed. check your logic: RETURN div(uint256(numerator) * REAL_ONE,uint256(denominator) * REAL_ONE)
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: IF (_params[4] > i) && (_params[4] <= i * 2)
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: IF proposal.state == ProposalState.Boosted && ((now - proposal.times[1]) >= (params.boostedVotePeriodLimit - params.quietEndingPeriod)) || proposal.state == ProposalState.QuietEndingPeriod
 In GenesisProtocolLogic._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In GenesisProtocol.shouldBoost, it can be over/underflowed. check your logic: RETURN (_score(_proposalId) > threshold(proposal.paramsHash,proposal.organizationId))
 In GenesisProtocol._stake, it can be over/underflowed. check your logic: IF _execute(_proposalId)
 In ERC20Burnable._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20Burnable.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burnFrom(from,value)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE executionBar = (totalReputation / 100) * params.queuedVoteRequiredPercentage
 In DAOToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In Reputation.updateValueAtNow, it can be over/underflowed. check your logic: NEW VARIABLE newCheckPoint = checkpoints[checkpoints.length ++]
 In GenesisProtocol.setParameters, it can be over/underflowed. check your logic: EXPRESSION i = i * 2
 In DAOToken.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(_to,_amount)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocol.stake, it can be over/underflowed. check your logic: RETURN _stake(_proposalId,_vote,_amount,msg.sender)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In DAOToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,value)
 In Reputation.burn, it can be over/underflowed. check your logic: EXPRESSION updateValueAtNow(balances[_user],previousBalanceFrom - amountBurned)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In RealMath.div, it can be over/underflowed. check your logic: RETURN uint256((uint256(realNumerator) * REAL_ONE) / uint256(realDenominator))
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: IF (now - proposal.times[2]) >= params.preBoostedVotePeriodLimit
 In GenesisProtocol.internalVote, it can be over/underflowed. check your logic: RETURN _execute(_proposalId)
 In GenesisProtocol._execute, it can be over/underflowed. check your logic: NEW VARIABLE proposalScore = _score(_proposalId)
 In GenesisProtocolLogic._execute, it can be over/underflowed. check your logic: EXPRESSION averagesDownstakesOfBoosted[proposal.organizationId] = (averageDownstakesOfBoosted.mul(boostedProposals + 1).sub(proposal.stakes[NO])) / boostedProposals
 
line_number: 1838

Filename: 0x94534caebd1887be3d57179728a670a3436bb443_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In IEOIBS.constructor, it can be over/underflowed. check your logic: EXPRESSION firstLimit = 60000000 * 1000000000000000000
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In IEOIBS.constructor, it can be over/underflowed. check your logic: EXPRESSION secondLimit = 30000000 * 1000000000000000000
 In IrbisToken.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = 100000000 * 1000000000000000000
 
line_number: 147
line_number: 218
line_number: 299

Filename: 0x946551dd05c5abd7cc808927480225ce36d8c475_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In Token.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply_ = 1350852214721 * 10 ** uint256(decimals - 2)
 In Token.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In FreezeToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In Token.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In FreezeToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 
line_number: 214
line_number: 254
line_number: 311
line_number: 318
line_number: 320

Filename: 0x9582bea37cc8881fb36277d7675c45bcd9334e1a_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In LAZE.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 10000 * decimalFactor
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In LAZE.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0x98439bb859c63cf1b0b24610d4e83ca2c0e8981f_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In SafeLife.lockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_holder,_amount,now + _afterTime)
 In SafeLife.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeLife.constructor, it can be over/underflowed. check your logic: EXPRESSION super._mint(msg.sender,initialSupply)
 In SafeLife.transferWithLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(_releaseTime,_value))
 In SafeLife.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In SafeLife.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 In SafeLife.mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(_to,_amount)
 In SafeLife.transfer, it can be over/underflowed. check your logic: EXPRESSION releaseLock(msg.sender)
 In SafeLife.afterTime, it can be over/underflowed. check your logic: RETURN now + _value
 In SafeLife.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i --
 In SafeLife.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeLife.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeLife.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeLife.transferFrom, it can be over/underflowed. check your logic: EXPRESSION releaseLock(_from)
 In SafeLife.unlock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In SafeLife.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeLife.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 In SafeLife.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_who,_value)
 In SafeLife._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In SafeLife.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_to,_value,now + _afterTime)
 In SafeLife.balanceOf, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeLife.releaseLock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In SafeLife.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In SafeLife.lockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(now + _afterTime,_amount))
 In SafeLife.lock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(_releaseTime,_amount))
 In SafeLife.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT initialSupply = 500000000 * (10 ** uint256(decimals))
 In SafeLife.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(now + _afterTime,_value))
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 122
line_number: 133
line_number: 143
line_number: 381
line_number: 391
line_number: 416
line_number: 431

Filename: 0xB59c30C7d55d719641d7120EF099c49f456622fB_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In DappChannel.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = 150000 * (10 ** decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 94
line_number: 96
line_number: 138
line_number: 151

Filename: 0xC5395f5290bc754352eBff6FfdB94E317Bf75222_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In DJCoin.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT tokensPerBlock = 1 * 10 ** DECIMALS
 In DJCoin.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT TOTAL_GONS = MAX_UINT256 - (MAX_UINT256 % INITIAL_FRAGMENTS_SUPPLY)
 In DJCoin.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_FRAGMENTS_SUPPLY = 210000000 * 10 ** DECIMALS
 In DJCoin.changetokensPerBlock, it can be over/underflowed. check your logic: EXPRESSION tokensPerBlock = _newtokensPerBlock * 10 ** DECIMALS
 
line_number: 193
line_number: 249
line_number: 279
line_number: 291

Filename: 0xa3ee21c306a700e682abcdfe9baa6a08f3820419_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GluwaCreditcoinVestingToken.slitherConstructorConstantVariables() (0xa3ee21c306a700e682abcdfe9baa6a08f3820419_integerOverflow.sol#165-549) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT (0xa3ee21c306a700e682abcdfe9baa6a08f3820419_integerOverflow.sol#161)
 check: over-underflow
impact: Low
confidence: Low
description
In GluwaCreditcoinVestingToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balanceOf(from) >= value,Insufficient balance)
 In GluwaCreditcoinVestingToken.burn, it can be over/underflowed. check your logic: EXPRESSION _removeTokensFromAddress(msg.sender,value)
 In SafeMath.multiply, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In GluwaCreditcoinVestingToken.recordSales365Days, it can be over/underflowed. check your logic: EXPRESSION recordSale365Days(tokenHolders[i],amounts[i])
 In GluwaCreditcoinVestingToken.vestedBalanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance365Days = vestedBalanceOf365Days(tokenHolder)
 In GluwaCreditcoinVestingToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT creditcoinSalesLimit = creditcoinLimitInFrac * 3 / 10
 In GluwaCreditcoinVestingToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _removeTokensFromAddress(msg.sender,value)
 In GluwaCreditcoinVestingToken.recordSale2190Days, it can be over/underflowed. check your logic: EXPRESSION _recordSale(tokenHolder,SIX_YEAR_VESTING_IN_DAYS,numCoins)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In GluwaCreditcoinVestingToken.recordSales730Days, it can be over/underflowed. check your logic: EXPRESSION recordSale730Days(tokenHolders[i],amounts[i])
 In GluwaCreditcoinVestingToken.recordSales1095Days, it can be over/underflowed. check your logic: EXPRESSION recordSale1095Days(tokenHolders[i],amounts[i])
 In GluwaCreditcoinVestingToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _removeTokensFromAddress(from,value)
 In GluwaCreditcoinVestingToken.recordSale730Days, it can be over/underflowed. check your logic: EXPRESSION _recordSale(tokenHolder,TWO_YEAR_VESTING_IN_DAYS,numCoins)
 In GluwaCreditcoinVestingToken.recordSales183Days, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GluwaCreditcoinVestingToken.recordSales1095Days, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GluwaCreditcoinVestingToken.vestedBalanceOf365Days, it can be over/underflowed. check your logic: RETURN _calculateAvailableVestingTokensForPeriod(tokenHolder,ONE_YEAR_VESTING_IN_DAYS)
 In GluwaCreditcoinVestingToken.vestedBalanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance730Days = vestedBalanceOf730Days(tokenHolder)
 In GluwaCreditcoinVestingToken.vestedBalanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance2190Days = vestedBalanceOf2190Days(tokenHolder)
 In GluwaCreditcoinVestingToken.vestedBalanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance183Days = vestedBalanceOf183Days(tokenHolder)
 In GluwaCreditcoinVestingToken.vestedBalanceOf2190Days, it can be over/underflowed. check your logic: RETURN _calculateAvailableVestingTokensForPeriod(tokenHolder,SIX_YEAR_VESTING_IN_DAYS)
 In GluwaCreditcoinVestingToken.exchange, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balanceOf(msg.sender) >= value,Insufficient balance)
 In GluwaCreditcoinVestingToken.recordSales365Days, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GluwaCreditcoinVestingToken.vestedBalanceOf1095Days, it can be over/underflowed. check your logic: RETURN _calculateAvailableVestingTokensForPeriod(tokenHolder,THREE_YEAR_VESTING_IN_DAYS)
 In GluwaCreditcoinVestingToken.burn, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balanceOf(msg.sender) >= value,Insufficient balance)
 In GluwaCreditcoinVestingToken.balanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance = vestedBalanceOf(owner)
 In GluwaCreditcoinVestingToken.recordSales730Days, it can be over/underflowed. check your logic: EXPRESSION i ++
 In GluwaCreditcoinVestingToken.vestedBalanceOf183Days, it can be over/underflowed. check your logic: RETURN _calculateAvailableVestingTokensForPeriod(tokenHolder,SIX_MONTH_VESTING_IN_DAYS)
 In GluwaCreditcoinVestingToken.vestedBalanceOf730Days, it can be over/underflowed. check your logic: RETURN _calculateAvailableVestingTokensForPeriod(tokenHolder,TWO_YEAR_VESTING_IN_DAYS)
 In GluwaCreditcoinVestingToken.recordSales2190Days, it can be over/underflowed. check your logic: EXPRESSION recordSale2190Days(tokenHolders[i],amounts[i])
 In GluwaCreditcoinVestingToken.transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balanceOf(msg.sender) >= value,Insufficient balance)
 In GluwaCreditcoinVestingToken.recordSale183Days, it can be over/underflowed. check your logic: EXPRESSION _recordSale(tokenHolder,SIX_MONTH_VESTING_IN_DAYS,numCoins)
 In GluwaCreditcoinVestingToken._removeTokensFromAddress, it can be over/underflowed. check your logic: EXPRESSION _balances[from][USED_VESTED_AMOUNT] = _balances[from][USED_VESTED_AMOUNT].add(value - fromTransferBalance)
 In GluwaCreditcoinVestingToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _removeTokensFromAddress(from,value)
 In GluwaCreditcoinVestingToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT FRAC_IN1UNIT = 10 ** uint256(decimals)
 In GluwaCreditcoinVestingToken.exchange, it can be over/underflowed. check your logic: EXPRESSION _removeTokensFromAddress(msg.sender,value)
 In GluwaCreditcoinVestingToken.recordSale1095Days, it can be over/underflowed. check your logic: EXPRESSION _recordSale(tokenHolder,THREE_YEAR_VESTING_IN_DAYS,numCoins)
 In GluwaCreditcoinVestingToken._removeTokensFromAddress, it can be over/underflowed. check your logic: EXPRESSION _balances[from][TRANSFER_TOKENS_BALANCE] -= value
 In SafeMath.subtract, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In CreditcoinBase.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT FRAC_IN1UNIT = 10 ** uint256(decimals)
 In GluwaCreditcoinVestingToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balanceOf(from) >= value,Insufficient balance)
 In GluwaCreditcoinVestingToken.vestedBalanceOf, it can be over/underflowed. check your logic: NEW VARIABLE vestedBalance1095Days = vestedBalanceOf1095Days(tokenHolder)
 In GluwaCreditcoinVestingToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT
 In GluwaCreditcoinVestingToken.recordSales183Days, it can be over/underflowed. check your logic: EXPRESSION recordSale183Days(tokenHolders[i],amounts[i])
 In GluwaCreditcoinVestingToken.recordSale365Days, it can be over/underflowed. check your logic: EXPRESSION _recordSale(tokenHolder,ONE_YEAR_VESTING_IN_DAYS,numCoins)
 In CreditcoinBase.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT creditcoinLimitInFrac = 2000000000 * FRAC_IN1UNIT
 In GluwaCreditcoinVestingToken.recordSales2190Days, it can be over/underflowed. check your logic: EXPRESSION i ++
 
line_number: 243
line_number: 259

Filename: 0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- _balances[0x14fBA4aa05AEeC42336CB75bc30bF78dbC6b3f9F] = 2000000000 * 10 ** decimals (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#115)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- Transfer(address(0),0xdA78d97Fb07d945691916798CFF57324770a6C34,2000000000 * 10 ** decimals) (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#118)
 BITFRIENDZ.slitherConstructorVariables() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#109-248) uses literals with too many digits: 20000000000 recommended suffix: gwei
	- supply = 20000000000 * 10 ** decimals (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#132)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- Transfer(address(0),0x14fBA4aa05AEeC42336CB75bc30bF78dbC6b3f9F,2000000000 * 10 ** decimals) (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#116)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 15000000000 recommended suffix: gwei
	- _balances[address(this)] = 15000000000 * 10 ** decimals (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#121)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 15000000000 recommended suffix: gwei
	- Transfer(address(0),address(this),15000000000 * 10 ** decimals) (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#122)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- _balances[0xdA78d97Fb07d945691916798CFF57324770a6C34] = 2000000000 * 10 ** decimals (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#117)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 1000000000 recommended suffix: gwei
	- Transfer(address(0),0xF07e6A0EAbF18A3D8bB10e6E63c2E9e2d101C160,1000000000 * 10 ** decimals) (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#120)
 BITFRIENDZ.slitherConstructorVariables() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#109-248) uses literals with too many digits: 50000000000 recommended suffix: gwei
	- tokenPrice = 50000000000 (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#134)
 BITFRIENDZ.constructor() (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#113-123) uses literals with too many digits: 1000000000 recommended suffix: gwei
	- _balances[0xF07e6A0EAbF18A3D8bB10e6E63c2E9e2d101C160] = 1000000000 * 10 ** decimals (0xa562dc7657c333cac710175ae658ffa6f9414bbc_integerOverflow.sol#119)
 check: over-underflow
impact: Low
confidence: Low
description
In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(0),0xF07e6A0EAbF18A3D8bB10e6E63c2E9e2d101C160,1000000000 * 10 ** decimals)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: NEW VARIABLE amount = (msg.value * 10 ** decimals) / tokenPrice
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(this),msg.sender,amount + bonus)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION _balances[address(this)] = _balances[address(this)].sub(amount + bonus)
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(0),0xdA78d97Fb07d945691916798CFF57324770a6C34,2000000000 * 10 ** decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION _balances[address(this)] = _balances[address(this)].sub(amount + bonus)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION _balances[0xdA78d97Fb07d945691916798CFF57324770a6C34] = 2000000000 * 10 ** decimals
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(this),msg.sender,amount + bonus)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION _balances[msg.sender] = _balances[msg.sender].add(amount + bonus)
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: IF _balances[address(this)] < amount + bonus
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION _balances[msg.sender] = _balances[msg.sender].add(amount + bonus)
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 25)) / 100)
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 50)) / 100)
 In BITFRIENDZ.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT supply = 20000000000 * 10 ** decimals
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: IF _balances[address(this)] < amount + bonus
 In BITFRIENDZ.transfer, it can be over/underflowed. check your logic: EXPRESSION burn(value)
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(0),0x14fBA4aa05AEeC42336CB75bc30bF78dbC6b3f9F,2000000000 * 10 ** decimals)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 75)) / 100)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 25)) / 100)
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION _balances[0x14fBA4aa05AEeC42336CB75bc30bF78dbC6b3f9F] = 2000000000 * 10 ** decimals
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 10000) + (amount * 5625)) / 10000)
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: NEW VARIABLE amount = (msg.value * 10 ** decimals) / tokenPrice
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION _balances[address(this)] = 15000000000 * 10 ** decimals
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 75)) / 100)
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION Transfer(address(0),address(this),15000000000 * 10 ** decimals)
 In BITFRIENDZ.BuyTokens, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 100) + (amount * 50)) / 100)
 In BITFRIENDZ.constructor, it can be over/underflowed. check your logic: EXPRESSION _balances[0xF07e6A0EAbF18A3D8bB10e6E63c2E9e2d101C160] = 1000000000 * 10 ** decimals
 In BITFRIENDZ.fallback, it can be over/underflowed. check your logic: EXPRESSION bonus = (((amount * 10000) + (amount * 5625)) / 10000)
 
line_number: 165
line_number: 183
line_number: 185
line_number: 187
line_number: 243

Filename: 0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
SafeMath.slitherConstructorConstantVariables() (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#110-211) uses literals with too many digits: 18 recommended suffix: ether
	- WAD = 10 ** 18 (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#143)
 ShareholderVomer.changeIndividualVMRCup(address,uint256) (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#336-338) uses literals with too many digits: 18 recommended suffix: ether
	- individualVMRCup[userAddress] = minAmount * 10 ** 18 (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#337)
 ShareholderVomer.fallback() (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#426-475) uses literals with too many digits: 18 recommended suffix: ether
	- minBalanceRequired = MinBalanceVMR * 10 ** 18 (0xa79b2c8eb39dde841bd1981c48e012eff156ba5e_integerOverflow.sol#437)
 check: over-underflow
impact: Low
confidence: Low
description
In ShareholderVomer.getCredit, it can be over/underflowed. check your logic: IF totalAllowance != uint256(- 1)
 In ShareholderVomer.fallback, it can be over/underflowed. check your logic: EXPRESSION minBalanceRequired = MinBalanceVMR * 10 ** 18
 In ShareholderVomer.fallback, it can be over/underflowed. check your logic: EXPRESSION migrateDataFromOldContract(msg.sender,msg.sender)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In ShareholderVomer.changeIndividualVMRCup, it can be over/underflowed. check your logic: EXPRESSION individualVMRCup[userAddress] = minAmount * 10 ** 18
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT WAD = 10 ** 18
 In SafeMath.wmul, it can be over/underflowed. check your logic: EXPRESSION z = add(mul(x,y),WAD / 2) / WAD
 In ShareholderVomer.lockFunds, it can be over/underflowed. check your logic: EXPRESSION dateUntilFundsLocked = now + 2592000
 In ShareholderVomer.migrateDataFromOldContract, it can be over/underflowed. check your logic: NEW VARIABLE lastDatetime = block.timestamp - pendingReward.mul(2592000).mul(100).div(20).div(totalFunds)
 In SafeMath.wdiv, it can be over/underflowed. check your logic: EXPRESSION z = add(mul(x,WAD),y / 2) / y
 In ShareholderVomer.addDepositTokens, it can be over/underflowed. check your logic: EXPRESSION i ++
 In ShareholderVomer.fallback, it can be over/underflowed. check your logic: NEW VARIABLE reward = data.funds.mul(20).div(100).mul(block.timestamp - data.lastDatetime).div(2592000)
 In ShareholderVomer.getInfo, it can be over/underflowed. check your logic: EXPRESSION pendingReward = data.funds.mul(20).div(100).mul(block.timestamp - data.lastDatetime).div(2592000)
 
line_number: 315

Filename: 0xac39a4f0a3e5ae216f0d37838d271113353b2d3f_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In FrogInitPool.exit, it can be over/underflowed. check your logic: EXPRESSION getReward()
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In FrogInitPool.exit, it can be over/underflowed. check your logic: EXPRESSION withdrawStakeToken(balanceOf(msg.sender))
 In FrogInitPool.getReward, it can be over/underflowed. check your logic: NEW VARIABLE reward = earned(msg.sender)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In FrogInitPool.withdrawStakeToken, it can be over/underflowed. check your logic: EXPRESSION super.withdraw(amount)
 In FrogInitPool.stake, it can be over/underflowed. check your logic: EXPRESSION super.stake(amount)
 In FrogInitPool.notifyRewardAmount, it can be over/underflowed. check your logic: EXPRESSION updateReward(address(0))
 In FrogInitPool.earned, it can be over/underflowed. check your logic: RETURN balanceOf(account).mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(_gunit).add(rewards[account])
 In FrogInitPool.withdraw, it can be over/underflowed. check your logic: EXPRESSION super.withdraw(amount)
 In FrogInitPool.withdraw, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In FrogInitPool.exit, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 In FrogInitPool.notifyRewardAmount, it can be over/underflowed. check your logic: EXPRESSION _checkRewardRate()
 In FrogInitPool.stake, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 
line_number: 582
line_number: 584
line_number: 590
line_number: 592

Filename: 0xb22c2786a549b008517b67625f5296e8faf9589e_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
RentalProcessorToken.constructor() (0xb22c2786a549b008517b67625f5296e8faf9589e_integerOverflow.sol#281-283) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- _mint(msg.sender,2000000000 * (10 ** decimals)) (0xb22c2786a549b008517b67625f5296e8faf9589e_integerOverflow.sol#282)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In RentalProcessorToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In RentalProcessorToken._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In RentalProcessorToken.constructor, it can be over/underflowed. check your logic: EXPRESSION _mint(msg.sender,2000000000 * (10 ** decimals))
 In RentalProcessorToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 
line_number: 172
line_number: 192
line_number: 211

Filename: 0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
FixidityLib.mulPrecision() (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1246-1248) uses literals with too many digits: 1000000000000 recommended suffix: szabo
	- 1000000000000 (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1247)
 FixidityLib.fixed1() (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1237-1239) uses literals with too many digits: 1000000000000000000000000 recommended suffix: ether
	- 1000000000000000000000000 (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1238)
 FixidityLib.maxFixedDivisor() (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1343-1345) uses literals with too many digits: 1000000000000000000000000000000000000000000000000 recommended suffix: ether
	- 1000000000000000000000000000000000000000000000000 (0xb2e6e3d9af235434385c28bd31d98041a48226a6_integerOverflow.sol#1344)
 check: over-underflow
impact: Low
confidence: Low
description
In FixidityLib.subtract, it can be over/underflowed. check your logic: RETURN add(x,- y)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x2 = fractional(x)
 In BasePool.withdraw, it can be over/underflowed. check your logic: EXPRESSION notLocked()
 In UniformRandomNumber.uniform, it can be over/underflowed. check your logic: NEW VARIABLE min = - _upperBound % _upperBound
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: EXPRESSION j ++
 In BasePool.sponsorshipAndFeeBalanceOf, it can be over/underflowed. check your logic: RETURN balances[_sender] - drawState.balanceOf(_sender)
 In FixidityLib.reciprocal, it can be over/underflowed. check your logic: RETURN (fixed1() * fixed1()) / x
 In BasePool.openNextDraw, it can be over/underflowed. check your logic: EXPRESSION open(nextSecretHash)
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION tree.stack.length --
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: EXPRESSION values = new uint256[](tree.nodes.length - loopStartIndex)
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: EXPRESSION decimalDifference = _destinationDigits - _originDigits
 In BasePool.reward, it can be over/underflowed. check your logic: NEW VARIABLE drawId = currentCommittedDrawId()
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION tree.nodes.push(tree.nodes[parentIndex])
 In SortitionSumTreeFactory.updateParents, it can be over/underflowed. check your logic: EXPRESSION tree.nodes[parentIndex] = tree.nodes[parentIndex] + _value
 In BasePool._depositPoolFromCommitted, it can be over/underflowed. check your logic: EXPRESSION _depositFrom(_spender,_amount)
 In BasePool.withdraw, it can be over/underflowed. check your logic: NEW VARIABLE sponsorshipAndFees = sponsorshipAndFeeBalanceOf(msg.sender)
 In BasePool.withdraw, it can be over/underflowed. check your logic: EXPRESSION nonReentrant()
 In BasePool.depositSponsorship, it can be over/underflowed. check your logic: EXPRESSION nonReentrant()
 In FixidityLib.multiply, it can be over/underflowed. check your logic: EXPRESSION result = add(result,x1y2)
 In BasePool.currentCommittedDrawId, it can be over/underflowed. check your logic: RETURN drawState.openDrawIndex - 1
 In BasePool.openNextDraw, it can be over/underflowed. check your logic: IF currentCommittedDrawId() > 0
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION plusOrMinusValue = _value - tree.nodes[treeIndex]
 In FixidityLib.maxFixedSub, it can be over/underflowed. check your logic: RETURN - 28948022309329048855892746252171976963317496166410141009864396001978282409984
 In SortitionSumTreeFactory.draw, it can be over/underflowed. check your logic: NEW VARIABLE nodeIndex = (tree.K * treeIndex) + i
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION tree.nodes.push(_value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION tree.stack.push(treeIndex)
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In FixidityLib.divide, it can be over/underflowed. check your logic: RETURN multiply(x,reciprocal(y))
 In BasePool.depositPool, it can be over/underflowed. check your logic: EXPRESSION _depositPoolFrom(msg.sender,_amount)
 In SortitionSumTreeFactory.draw, it can be over/underflowed. check your logic: IF_LOOP (tree.K * treeIndex) + 1 < tree.nodes.length
 In BasePool.depositPool, it can be over/underflowed. check your logic: EXPRESSION nonReentrant()
 In Blocklock.canLock, it can be over/underflowed. check your logic: NEW VARIABLE endAt = lockEndAt(self)
 In DrawManager.balanceOf, it can be over/underflowed. check your logic: RETURN committedBalanceOf(drawState,_addr).add(openBalanceOf(drawState,_addr))
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: EXPRESSION i ++
 In BasePool.withdrawOpenDeposit, it can be over/underflowed. check your logic: EXPRESSION _withdraw(msg.sender,_amount)
 In DrawManager.withdrawCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,secondDrawIndex,0,_addr)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x1y1 = x1 * y1
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE y1 = integer(y) / fixed1()
 In DrawManager.deposit, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,openDrawIndex,currentAmount,_addr)
 In BasePool.depositSponsorship, it can be over/underflowed. check your logic: EXPRESSION _depositSponsorshipFrom(msg.sender,_amount)
 In BasePool.withdrawCommittedDeposit, it can be over/underflowed. check your logic: EXPRESSION _withdrawCommittedDepositAndEmit(msg.sender,_amount)
 In Blocklock.isLocked, it can be over/underflowed. check your logic: NEW VARIABLE endAt = lockEndAt(self)
 In BasePool.withdrawSponsorshipAndFee, it can be over/underflowed. check your logic: EXPRESSION _withdraw(msg.sender,_amount)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: EXPRESSION result = add(result,x2y2)
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: EXPRESSION decimalDifference = _originDigits - _destinationDigits
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In BasePool.rewardAndOpenNextDraw, it can be over/underflowed. check your logic: EXPRESSION reward(lastSecret,_salt)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE y2 = fractional(y)
 In DrawManager.depositCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,firstDrawIndex,firstAmount.add(_amount),_addr)
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: NEW VARIABLE newIndex = treeIndex + 1
 In FixidityLib.newFixed, it can be over/underflowed. check your logic: EXPRESSION require(bool)(x >= minNewFixed())
 In DrawManager.depositCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,self.usersFirstDrawIndex[_addr],_amount,_addr)
 In BasePool.rollover, it can be over/underflowed. check your logic: NEW VARIABLE drawId = currentCommittedDrawId()
 In BasePool.reward, it can be over/underflowed. check your logic: EXPRESSION requireCommittedNoReward()
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: RETURN x * (uint128(10) ** uint128(decimalDifference))
 In SortitionSumTreeFactory.updateParents, it can be over/underflowed. check your logic: EXPRESSION parentIndex = (parentIndex - 1) / tree.K
 In Blocklock.lock, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(canLock(self,blockNumber),Blocklock/no-lock)
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION plusOrMinusValue = tree.nodes[treeIndex] - _value
 In SortitionSumTreeFactory.createTree, it can be over/underflowed. check your logic: EXPRESSION tree.nodes.push(0)
 In DrawManager.withdrawCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,secondDrawIndex,secondRemaining,_addr)
 In DrawManager.deposit, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,firstDrawIndex,firstAmount.add(secondAmount),_addr)
 In FixidityLib.newFixedFraction, it can be over/underflowed. check your logic: RETURN divide(convertedNumerator,convertedDenominator)
 In BasePool._depositPoolFromCommitted, it can be over/underflowed. check your logic: EXPRESSION notLocked()
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE fixed_x1y1 = x1y1 * fixed1()
 In FixidityLib.fromFixed, it can be over/underflowed. check your logic: RETURN convertFixed(x,digits(),_destinationDigits)
 In Blocklock.lockEndAt, it can be over/underflowed. check your logic: NEW VARIABLE endAt = self.lockedAt + self.lockDuration
 In FixidityLib.minNewFixed, it can be over/underflowed. check your logic: RETURN - 57896044618658097711785492504343953926634992332820282
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION updateParents(self,_key,treeIndex,plusOrMinus,plusOrMinusValue)
 In BasePool.reward, it can be over/underflowed. check your logic: NEW VARIABLE winningAddress = calculateWinner(entropy)
 In FixidityLib.abs, it can be over/underflowed. check your logic: NEW VARIABLE result = - x
 In Blocklock.canLock, it can be over/underflowed. check your logic: RETURN (self.lockedAt == 0 || blockNumber >= endAt + self.cooldownDuration)
 In SortitionSumTreeFactory.draw, it can be over/underflowed. check your logic: EXPRESSION i ++
 In FixidityLib.newFixedFraction, it can be over/underflowed. check your logic: NEW VARIABLE convertedDenominator = newFixed(denominator)
 In BasePool.rolloverAndOpenNextDraw, it can be over/underflowed. check your logic: EXPRESSION rollover()
 In FixidityLib.newFixed, it can be over/underflowed. check your logic: RETURN convertFixed(x,_originDigits,digits())
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: EXPRESSION valuesIndex ++
 In BasePool.withdraw, it can be over/underflowed. check your logic: EXPRESSION _withdraw(msg.sender,balance)
 In PoolToken.init, it can be over/underflowed. check your logic: EXPRESSION i ++
 In BasePool.moveCommitted, it can be over/underflowed. check your logic: EXPRESSION onlyCommittedBalanceGteq(_from,_amount)
 In BasePool.withdrawSponsorshipAndFee, it can be over/underflowed. check your logic: NEW VARIABLE sponsorshipAndFees = sponsorshipAndFeeBalanceOf(msg.sender)
 In BasePool.rollover, it can be over/underflowed. check your logic: EXPRESSION requireCommittedNoReward()
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: EXPRESSION require(bool)(x <= maxInt256() / uint128(10) ** uint128(decimalDifference))
 In BasePool.withdrawCommittedDeposit, it can be over/underflowed. check your logic: RETURN _withdrawCommittedDepositAndEmit(_from,_amount)
 In DrawManager.withdraw, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,secondDrawIndex,0,_addr)
 In BasePool._withdrawCommittedDepositAndEmit, it can be over/underflowed. check your logic: EXPRESSION _withdraw(_from,_amount)
 In BasePool.transferBalanceToSponsorship, it can be over/underflowed. check your logic: EXPRESSION _depositSponsorshipFrom(address(this),token().balanceOf(address(this)))
 In FixidityLib.newFixed, it can be over/underflowed. check your logic: RETURN x * fixed1()
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION updateParents(self,_key,treeIndex,false,value)
 In DrawManager.drawWithEntropy, it can be over/underflowed. check your logic: RETURN draw(self,UniformRandomNumber.uniform(uint256(_entropy),committedSupply(self)))
 In FixidityLib.newFixedFraction, it can be over/underflowed. check your logic: NEW VARIABLE convertedNumerator = newFixed(numerator)
 In BasePool.openNextDraw, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(currentCommittedDrawHasBeenRewarded(),Pool/not-reward)
 In DrawManager.deposit, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,secondDrawIndex,0,_addr)
 In FixidityLib.minInt256, it can be over/underflowed. check your logic: RETURN - 57896044618658097711785492504343953926634992332820282019728792003956564819968
 In BasePool._depositPoolFrom, it can be over/underflowed. check your logic: EXPRESSION _depositFrom(_spender,_amount)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x1y2 = x1 * y2
 In BasePool.reward, it can be over/underflowed. check your logic: EXPRESSION awardWinnings(winningAddress,netWinnings)
 In BasePool.moveCommitted, it can be over/underflowed. check your logic: EXPRESSION notLocked()
 In BasePool.currentCommittedDrawHasBeenRewarded, it can be over/underflowed. check your logic: NEW VARIABLE draw = draws[currentCommittedDrawId()]
 In DrawManager.withdraw, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,firstDrawIndex,0,_addr)
 In FixidityLib.integer, it can be over/underflowed. check your logic: RETURN (x / fixed1()) * fixed1()
 In BasePool.withdrawCommittedDeposit, it can be over/underflowed. check your logic: EXPRESSION notLocked()
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: IF (tree.K * i) + 1 >= tree.nodes.length
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x2y1 = x2 * y1
 In FixidityLib.add, it can be over/underflowed. check your logic: NEW VARIABLE z = x + y
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: IF loopStartIndex + _count > tree.nodes.length
 In BasePool.reward, it can be over/underflowed. check your logic: EXPRESSION nonReentrant()
 In FixidityLib.multiply, it can be over/underflowed. check your logic: EXPRESSION result = add(result,x2y1)
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: EXPRESSION require(bool)(x >= minInt256() / uint128(10) ** uint128(decimalDifference))
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION updateParents(self,_key,treeIndex,true,_value)
 In SortitionSumTreeFactory.updateParents, it can be over/underflowed. check your logic: EXPRESSION tree.nodes[parentIndex] = tree.nodes[parentIndex] - _value
 In BasePool.rolloverAndOpenNextDraw, it can be over/underflowed. check your logic: EXPRESSION openNextDraw(nextSecretHash)
 In BasePool.reward, it can be over/underflowed. check your logic: EXPRESSION onlyLocked()
 In DrawManager.withdrawCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,firstDrawIndex,remaining,_addr)
 In BasePool._depositSponsorshipFrom, it can be over/underflowed. check your logic: EXPRESSION _depositFrom(_spender,_amount)
 In RecipientWhitelistPoolToken.init, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SortitionSumTreeFactory.queryLeafs, it can be over/underflowed. check your logic: NEW VARIABLE loopStartIndex = startIndex + _cursor
 In BasePool.reward, it can be over/underflowed. check your logic: NEW VARIABLE fee = calculateFee(draw.feeFraction,grossWinnings)
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: IF treeIndex != 1 && (treeIndex - 1) % tree.K == 0
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x2y2 = x2 * y2
 In Blocklock.cooldownEndAt, it can be over/underflowed. check your logic: RETURN lockEndAt(self) + self.cooldownDuration
 In DrawManager.withdrawOpen, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,self.openDrawIndex,remaining,_addr)
 In SortitionSumTreeFactory.draw, it can be over/underflowed. check your logic: EXPRESSION currentDrawnNumber -= nodeValue
 In BasePool.rewardAndOpenNextDraw, it can be over/underflowed. check your logic: EXPRESSION openNextDraw(nextSecretHash)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In FixidityLib.multiply, it can be over/underflowed. check your logic: NEW VARIABLE x1 = integer(x) / fixed1()
 In SortitionSumTreeFactory.set, it can be over/underflowed. check your logic: EXPRESSION treeIndex = tree.stack[tree.stack.length - 1]
 In DrawManager.withdrawCommitted, it can be over/underflowed. check your logic: EXPRESSION drawSet(self,firstDrawIndex,0,_addr)
 In FixidityLib.convertFixed, it can be over/underflowed. check your logic: RETURN x / (uint128(10) ** uint128(decimalDifference))
 In FixidityLib.fractional, it can be over/underflowed. check your logic: RETURN x - (x / fixed1()) * fixed1()
 
line_number: 945
line_number: 2274
line_number: 2276

Filename: 0xb7918f5808257e4b7e5e303c33f7bb0364b620aa_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In UniLpRewards.earned, it can be over/underflowed. check your logic: RETURN _balances[account].mul(rewardPerToken().sub(userRewardPerTokenPaid[account])).div(1e18).add(rewards[account])
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In UniLpRewards.stake, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In UniLpRewards.notifyRewardAmount, it can be over/underflowed. check your logic: EXPRESSION updateReward(address(0))
 In UniLpRewards.getReward, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In UniLpRewards.exit, it can be over/underflowed. check your logic: EXPRESSION withdraw(_balances[msg.sender])
 In UniLpRewards.withdraw, it can be over/underflowed. check your logic: EXPRESSION updateReward(msg.sender)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In UniLpRewards.exit, it can be over/underflowed. check your logic: EXPRESSION getReward()
 In Math.average, it can be over/underflowed. check your logic: RETURN (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2)
 
line_number: 687
line_number: 689
line_number: 697
line_number: 699

Filename: 0xb9c37445b9564652a4b46ffbdf6dbf0d53e0605f_integerOverflow.sol
Output: Detecting specific vulnerabilities
Not supported file type
line_number: 57
line_number: 59
line_number: 70
line_number: 72
line_number: 74

Filename: 0xbaf33a94e7d2b50822e9f6047689d3e87673de6a_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
TokenERC20.constructor() (0xbaf33a94e7d2b50822e9f6047689d3e87673de6a_integerOverflow.sol#79-86) uses literals with too many digits: 9 recommended suffix: gwei
	- _totalSupply = 10 ** 9 * 10 ** uint256(decimals) (0xbaf33a94e7d2b50822e9f6047689d3e87673de6a_integerOverflow.sol#83)
 check: over-underflow
impact: Low
confidence: Low
description
In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 10 ** 9 * 10 ** uint256(decimals)
 In UNIIS_ERC20.getAirdrop, it can be over/underflowed. check your logic: EXPRESSION aTot ++
 In UNIIS_ERC20.tokenSale, it can be over/underflowed. check your logic: EXPRESSION sTot ++
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In UNIIS_ERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 10 ** 9 * 10 ** uint256(decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In UNIIS_ERC20.tokenSale, it can be over/underflowed. check your logic: EXPRESSION _tkns = sChunk * _price
 
line_number: 95
line_number: 97
line_number: 108
line_number: 110
line_number: 112

Filename: 0xbca22aa04ced4458c287df14dff8cb427b2466d5_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In EtherX1.playGame, it can be over/underflowed. check your logic: EXPRESSION checkSuperBonus(_referrer)
 In EtherX1.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,_dailyIncome.mul(remainingTimeForPayout))
 In EtherX1.playGame, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDirect(msg.sender,amount.mul(20).div(100))
 In EtherX1.distributeTopInvestors, it can be over/underflowed. check your logic: EXPRESSION i ++
 In EtherX1.referralBonusTransferDirect, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In EtherX1.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: EXPRESSION i ++
 In EtherX1.fallback, it can be over/underflowed. check your logic: EXPRESSION playGame(address(0x0))
 In EtherX1.startNewRound, it can be over/underflowed. check your logic: NEW VARIABLE distributedInvestorAwards = distributeTopInvestors()
 In EtherX1.getPlayerInfo, it can be over/underflowed. check your logic: EXPRESSION remainingTimeForPayout = (player[_playerAddress].lastSettledTime + payoutPeriod).sub(now)
 In EtherX1.referralBonusTransferDirect, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In EtherX1.settleIncome, it can be over/underflowed. check your logic: IF now > player[_playerAddress].lastSettledTime + payoutPeriod
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In EtherX1.referralBonusTransferDailyROI, it can be over/underflowed. check your logic: IF player[_nextReferrer].referralCount >= i + 1
 In EtherX1.withdrawIncome, it can be over/underflowed. check your logic: EXPRESSION settleIncome(_playerAddress)
 In EtherX1.startNewRound, it can be over/underflowed. check your logic: NEW VARIABLE distributedSponsorAwards = distributeTopPromoters()
 In EtherX1.startNewRound, it can be over/underflowed. check your logic: EXPRESSION roundID ++
 In EtherX1.startNewRound, it can be over/underflowed. check your logic: EXPRESSION _roundID ++
 In EtherX1.withdrawIncome, it can be over/underflowed. check your logic: NEW VARIABLE _earnings = player[_playerAddress].dailyIncome + player[_playerAddress].directReferralIncome + player[_playerAddress].roiReferralIncome + player[_playerAddress].investorPoolIncome + player[_playerAddress].sponsorPoolIncome + player[_playerAddress].superIncome
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In EtherX1.getPlayerInfo, it can be over/underflowed. check your logic: IF player[_playerAddress].lastSettledTime + payoutPeriod >= now
 In EtherX1.distributeTopPromoters, it can be over/underflowed. check your logic: EXPRESSION i ++
 In EtherX1.constructor, it can be over/underflowed. check your logic: EXPRESSION round[1].endTime = now + poolTime
 In EtherX1.settleIncome, it can be over/underflowed. check your logic: EXPRESSION referralBonusTransferDailyROI(_playerAddress,temp)
 
line_number: 921
line_number: 930
line_number: 937
line_number: 939

Filename: 0xbd87e086b2ac6b84eb84b9fa4459f3c22543742d_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
LIFE.constructor() (0xbd87e086b2ac6b84eb84b9fa4459f3c22543742d_integerOverflow.sol#305-313) uses literals with too many digits: 1000000000000000000 recommended suffix: ether
	- totalSupply = 100000000 * 1000000000000000000 (0xbd87e086b2ac6b84eb84b9fa4459f3c22543742d_integerOverflow.sol#309)
 check: over-underflow
impact: Low
confidence: Low
description
In LIFE.transferFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(_from) >= _value)
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In LIFE.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In LIFE.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = 100000000 * 1000000000000000000
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In LIFE.transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(msg.sender))
 In LIFE.freezeTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(_owner))
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In LIFE.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In LIFE.burnTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(msg.sender) >= _tokens)
 In LIFE.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In LIFE.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 
line_number: 120
line_number: 122
line_number: 162
line_number: 203
line_number: 214
line_number: 375
line_number: 377

Filename: 0xbfec19e7cd47fe4b1022fdc4c652ee7bd85a9d13_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In MagnetFinance.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 21000 * decimalFactor
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In MagnetFinance.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0xc00e1664bb61fdcca66e5abee64e7c3b675869e5_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
NZT.constructor() (0xc00e1664bb61fdcca66e5abee64e7c3b675869e5_integerOverflow.sol#305-313) uses literals with too many digits: 1000000000000000000 recommended suffix: ether
	- totalSupply = 50000000 * 1000000000000000000 (0xc00e1664bb61fdcca66e5abee64e7c3b675869e5_integerOverflow.sol#309)
 check: over-underflow
impact: Low
confidence: Low
description
In NZT.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = 50000000 * 1000000000000000000
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In NZT.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In NZT.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In NZT.burnTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(msg.sender) >= _tokens)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In NZT.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In NZT.transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(msg.sender))
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In NZT.freezeTokens, it can be over/underflowed. check your logic: EXPRESSION require(bool)(_value <= balanceOf(_owner))
 In NZT.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In NZT.transferFrom, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf(_from) >= _value)
 
line_number: 120
line_number: 122
line_number: 162
line_number: 203
line_number: 214
line_number: 375
line_number: 377

Filename: 0xc3c94c3f602e9b6991157bc223c9269d499019e2_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In UniswapERC20.addLiquidityPool, it can be over/underflowed. check your logic: NEW VARIABLE amountB = newReserveB - oldReserveB
 In UniswapERC20.getInputPrice, it can be over/underflowed. check your logic: RETURN getInputPrice(amountSold,inputReserve,outputReserve)
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE amountSold = newInputReserve - oldInputReserve
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE amountBought = getInputPrice(amountSold,oldInputReserve,currentOutputReserve)
 In UniswapERC20.swapBForA, it can be over/underflowed. check your logic: EXPRESSION (amountSold,amountBought) = swap(tokenB,tokenA,recipient)
 In UniswapERC20.addLiquidityPool, it can be over/underflowed. check your logic: NEW VARIABLE amountA = newReserveA - oldReserveA
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In UniswapERC20.swapAForB, it can be over/underflowed. check your logic: EXPRESSION (amountSold,amountBought) = swap(tokenA,tokenB,recipient)
 In UniswapERC20.swap, it can be over/underflowed. check your logic: NEW VARIABLE newOutputReserve = currentOutputReserve - amountBought
 
line_number: 63
line_number: 71
line_number: 74
line_number: 76
line_number: 89
line_number: 91
line_number: 260

Filename: 0xc6a57e7fe10b37d1e1f678247b9b25c6a2d8d7f7_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In MoonStaking.getEarnedTpool, it can be over/underflowed. check your logic: RETURN _getEarned(pool.rate,pool.adapter,stakingPool)
 In MoonStaking.withdrawEPool, it can be over/underflowed. check your logic: EXPRESSION _vault.transferToken(moon,_msgSender(),_getEarned(eRate,eAdapter,eStakingPool))
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In MoonStaking.withdrawTokenPool, it can be over/underflowed. check your logic: EXPRESSION _vault.transferToken(moon,_msgSender(),_getEarned(pool.rate,pool.adapter,tokenStakingPool))
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In MoonStaking.claimMoonInTpool, it can be over/underflowed. check your logic: EXPRESSION _vault.transferToken(moon,_msgSender(),_getEarned(pool.rate,pool.adapter,tokenStakingPool))
 In MoonStaking.stakeE, it can be over/underflowed. check your logic: EXPRESSION ePool.earned = ePool.earned.add(_getEarned(eRate,eAdapter,ePool))
 In MoonStaking.stake, it can be over/underflowed. check your logic: EXPRESSION tokenPool.earned = tokenPool.earned.add(_getEarned(pool.rate,pool.adapter,tokenPool))
 In MoonStaking.getEarnedEpool, it can be over/underflowed. check your logic: RETURN _getEarned(eRate,eAdapter,pool)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 In MoonStaking.claimMoonInEpool, it can be over/underflowed. check your logic: EXPRESSION _vault.transferToken(moon,_msgSender(),_getEarned(eRate,eAdapter,eStakingPool))
 
line_number: 942
line_number: 944

Filename: 0xc94551ac84557c143f0905c6afff09f58c453361_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
AOLibrary.slitherConstructorConstantVariables() (0xc94551ac84557c143f0905c6afff09f58c453361_integerOverflow.sol#356-658) uses literals with too many digits: 6 recommended suffix: gwei
	- _MULTIPLIER_DIVISOR = 10 ** 6 (0xc94551ac84557c143f0905c6afff09f58c453361_integerOverflow.sol#359)
 AOLibrary.slitherConstructorConstantVariables() (0xc94551ac84557c143f0905c6afff09f58c453361_integerOverflow.sol#356-658) uses literals with too many digits: 6 recommended suffix: gwei
	- _PERCENTAGE_DIVISOR = 10 ** 6 (0xc94551ac84557c143f0905c6afff09f58c453361_integerOverflow.sol#360)
 check: over-underflow
impact: Low
confidence: Low
description
In AOIonInterface.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In AOIonInterface.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In AOIonInterface.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In AOIonInterface.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In AOTera.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _MULTIPLIER_DIVISOR = 10 ** 6
 In AOIonInterface.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf[_to] + _value > balanceOf[_to])
 In AOTera.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _PERCENTAGE_DIVISOR = 10 ** 6
 In AOTera.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In AOTera.buy, it can be over/underflowed. check your logic: EXPRESSION _transfer(address(this),msg.sender,amount)
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In AOTera.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOLibrary.numDigits, it can be over/underflowed. check your logic: EXPRESSION digits ++
 In AOTera.sell, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,address(this),amount)
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In AOIonInterface.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_to] += _value
 In AOIonInterface.buy, it can be over/underflowed. check your logic: EXPRESSION _transfer(address(this),msg.sender,amount)
 In AOIonInterface.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In AOTera.transferBetweenPublicKeys, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In AOTera.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In AOIonInterface.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOIonInterface.sell, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,address(this),amount)
 In AOIonInterface.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOTera.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In AOTera.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOTera.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In AOTera.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOLibrary.calculateNetworkBonusAmount, it can be over/underflowed. check your logic: NEW VARIABLE bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount,_totalPrimordialMintable,_totalPrimordialMinted,_startingMultiplier,_endingMultiplier)
 In AOIonInterface.transferBetweenPublicKeys, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: NEW VARIABLE previousBalances = balanceOf[_from] + balanceOf[_to]
 In AOIonInterface.whitelistTransferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In AOTera.whitelistTransferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)
 
line_number: 884
line_number: 886
line_number: 900
line_number: 902
line_number: 917
line_number: 919
line_number: 931
line_number: 933
line_number: 947
line_number: 949
line_number: 965

Filename: 0xccbc1cce102a7656f1e2f0d59a5be8c1faf35850_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
BZQToken.constructor() (0xccbc1cce102a7656f1e2f0d59a5be8c1faf35850_integerOverflow.sol#241-242) uses literals with too many digits: 1000000000 recommended suffix: gwei
	- TokenERC20(1000000000,BZQToken,BZQ) (0xccbc1cce102a7656f1e2f0d59a5be8c1faf35850_integerOverflow.sol#241)
 check: over-underflow
impact: Low
confidence: Low
description
In BZQToken.constructor, it can be over/underflowed. check your logic: EXPRESSION TokenERC20(1000000000,BZQToken,BZQ)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In BZQToken.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In BZQToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In BZQToken.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 
line_number: 185
line_number: 212
line_number: 214
line_number: 222
line_number: 224
line_number: 226

Filename: 0xcd10fb882c05e7d16483522ff98a2fe2efbe0cf9_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In berg_token.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT decimalFactor = 10 ** uint256(decimals)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In berg_token.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT totalSupply = 15000 * decimalFactor
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 
line_number: 78
line_number: 91
line_number: 105
line_number: 116

Filename: 0xcdc7671af48ab852484838945b2b35dfeb9f49cb_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
MilliMeter.slitherConstructorConstantVariables() (0xcdc7671af48ab852484838945b2b35dfeb9f49cb_integerOverflow.sol#291-574) uses literals with too many digits: 2000000000 recommended suffix: gwei
	- initialSupply = 2000000000 * (10 ** uint256(decimals)) (0xcdc7671af48ab852484838945b2b35dfeb9f49cb_integerOverflow.sol#295)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In MilliMeter.unlock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In MilliMeter.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In MilliMeter.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i --
 In MilliMeter.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In MilliMeter.constructor, it can be over/underflowed. check your logic: EXPRESSION super._mint(msg.sender,initialSupply)
 In MilliMeter.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In MilliMeter.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In MilliMeter.releaseLock, it can be over/underflowed. check your logic: IF i != lockInfo[_holder].length - 1
 In MilliMeter.lock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(_releaseTime,_amount))
 In MilliMeter.afterTime, it can be over/underflowed. check your logic: RETURN now + _value
 In MilliMeter.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_to,_value,now + _afterTime)
 In MilliMeter.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT initialSupply = 2000000000 * (10 ** uint256(decimals))
 In MilliMeter.transferWithLockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(now + _afterTime,_value))
 In MilliMeter.releaseLock, it can be over/underflowed. check your logic: EXPRESSION i ++
 In MilliMeter.balanceOf, it can be over/underflowed. check your logic: EXPRESSION i ++
 In MilliMeter.lockAfter, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].push(LockInfo(now + _afterTime,_amount))
 In MilliMeter.transfer, it can be over/underflowed. check your logic: EXPRESSION releaseLock(msg.sender)
 In MilliMeter._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,value)
 In MilliMeter.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_who,_value)
 In MilliMeter.releaseLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 In MilliMeter.transferFrom, it can be over/underflowed. check your logic: EXPRESSION releaseLock(_from)
 In MilliMeter.lockAfter, it can be over/underflowed. check your logic: EXPRESSION Lock(_holder,_amount,now + _afterTime)
 In MilliMeter.mint, it can be over/underflowed. check your logic: EXPRESSION super._mint(_to,_amount)
 In MilliMeter.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder].length --
 In MilliMeter.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In MilliMeter.transferWithLock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_to].push(LockInfo(_releaseTime,_value))
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In MilliMeter.unlock, it can be over/underflowed. check your logic: EXPRESSION lockInfo[_holder][i] = lockInfo[_holder][lockInfo[_holder].length - 1]
 
line_number: 186
line_number: 206
line_number: 225
line_number: 505
line_number: 515
line_number: 540
line_number: 555

Filename: 0xcf0057a6b29d3fb4d0e970e8438d921e641d1066_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
AOLibrary.slitherConstructorConstantVariables() (0xcf0057a6b29d3fb4d0e970e8438d921e641d1066_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _MULTIPLIER_DIVISOR = 10 ** 6 (0xcf0057a6b29d3fb4d0e970e8438d921e641d1066_integerOverflow.sol#343)
 AOLibrary.slitherConstructorConstantVariables() (0xcf0057a6b29d3fb4d0e970e8438d921e641d1066_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _PERCENTAGE_DIVISOR = 10 ** 6 (0xcf0057a6b29d3fb4d0e970e8438d921e641d1066_integerOverflow.sol#344)
 check: over-underflow
impact: Low
confidence: Low
description
In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _MULTIPLIER_DIVISOR = 10 ** 6
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf[_to] + _value > balanceOf[_to])
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _PERCENTAGE_DIVISOR = 10 ** 6
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In LogosGiga.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOLibrary.numDigits, it can be over/underflowed. check your logic: EXPRESSION digits ++
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_to] += _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In LogosGiga.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TAOCurrency.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In AOLibrary.calculateNetworkBonusAmount, it can be over/underflowed. check your logic: NEW VARIABLE bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount,_totalPrimordialMintable,_totalPrimordialMinted,_startingMultiplier,_endingMultiplier)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: NEW VARIABLE previousBalances = balanceOf[_from] + balanceOf[_to]
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)
 In TAOCurrency.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 
line_number: 815

Filename: 0xd67b1Db49801b6F4c96a01a4F7964233150dc58b_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
KaratBankCoin.slitherConstructorConstantVariables() (0xd67b1Db49801b6F4c96a01a4F7964233150dc58b_integerOverflow.sol#242-288) uses literals with too many digits: 6 recommended suffix: gwei
	- INITIAL_SUPPLY = (12000 * (10 ** 6)) * (10 ** uint256(decimals)) (0xd67b1Db49801b6F4c96a01a4F7964233150dc58b_integerOverflow.sol#248)
 check: over-underflow
impact: Low
confidence: Low
description
In KaratBankCoin.send, it can be over/underflowed. check your logic: EXPRESSION sendp(addr,amount)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In KaratBankCoin.sendp, it can be over/underflowed. check your logic: EXPRESSION deposit(addr,amount)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In KaratBankCoin.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT INITIAL_SUPPLY = (12000 * (10 ** 6)) * (10 ** uint256(decimals))
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In InvestorsFeature.deposit, it can be over/underflowed. check your logic: EXPRESSION investors.push(investor)
 In KaratBankCoin.deposit, it can be over/underflowed. check your logic: EXPRESSION investors.push(investor)
 In InvestorsFeature.sendp, it can be over/underflowed. check your logic: EXPRESSION deposit(addr,amount)
 
line_number: 80
line_number: 119
line_number: 159
line_number: 170
line_number: 277

Filename: 0xd7ba91b3ede1698a7d1f991d7d5bd9c0c8995a58_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 
line_number: 158
line_number: 160
line_number: 162
line_number: 170
line_number: 172
line_number: 174
line_number: 176
line_number: 184
line_number: 186
line_number: 188
line_number: 196
line_number: 198
line_number: 200
line_number: 202
line_number: 207
line_number: 209
line_number: 211

Filename: 0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
MainSale.slitherConstructorVariables() (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#825-970) uses literals with too many digits: 100000000000000 recommended suffix: szabo
	- hardcap = 100000000000000000000000000000000 (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#836)
 Bears.constructor(address,address) (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#38-43) uses literals with too many digits: 9999999999999999999000000000000000000 recommended suffix: ether
	- CBCTokenContract.approve(_bankAddress,9999999999999999999000000000000000000) (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#42)
 Bulls.constructor(address,address) (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#50-55) uses literals with too many digits: 9999999999999999999000000000000000000 recommended suffix: ether
	- CBCTokenContract.approve(_bankAddress,9999999999999999999000000000000000000) (0xd9df383b7ef9b8a5cebb5af0d902591f87f218bb_integerOverflow.sol#54)
 check: over-underflow
impact: Low
confidence: Low
description
In ExchangeRate.updateRates, it can be over/underflowed. check your logic: EXPRESSION i ++
 In Bank.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT lastDeadline = 60 * 60 * 24 * 7
 In MintableToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_who,_value)
 In Authorizable.addAuthorized, it can be over/underflowed. check your logic: EXPRESSION authorizers[authorizers.length - 1] = _addr
 In MintableToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In Bank.calculateProbability, it can be over/underflowed. check your logic: EXPRESSION probabilityOfBulls = 10000 - probabilityOfBears
 In MainSale.createTokens, it can be over/underflowed. check your logic: EXPRESSION saleIsOn()
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In MainSale.addAuthorized, it can be over/underflowed. check your logic: EXPRESSION authorizers[authorizers.length - 1] = _addr
 In Authorizable.getAuthorizer, it can be over/underflowed. check your logic: RETURN address(authorizers[authorizerIndex + 1])
 In MainSale.addAuthorized, it can be over/underflowed. check your logic: EXPRESSION authorizers.length ++
 In MintableToken.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In CBCToken.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(_who,_value)
 In StandardToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In MainSale.createTokens, it can be over/underflowed. check your logic: EXPRESSION isUnderHardCap()
 In BasicToken.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In CBCToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION super.transferFrom(_from,_to,_value)
 In CBCToken.transferFrom, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(3 * 32)
 In Bank.constructor, it can be over/underflowed. check your logic: EXPRESSION currentDeadline = block.timestamp + 60 * 60 * 24 * 3
 In StandardToken.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In Bank.setInfo, it can be over/underflowed. check your logic: EXPRESSION countOfBears ++
 In Bank.setInfo, it can be over/underflowed. check your logic: EXPRESSION countOfBulls ++
 In ExchangeRate.updateRates, it can be over/underflowed. check your logic: NEW VARIABLE rate = data[i * 2 + 1]
 In MainSale.fallback, it can be over/underflowed. check your logic: EXPRESSION createTokens(msg.sender)
 In Bank.calculateProbability, it can be over/underflowed. check your logic: EXPRESSION probabilityOfBears = 10000 - probabilityOfBulls
 In CBCToken.transfer, it can be over/underflowed. check your logic: EXPRESSION super.transfer(_to,_value)
 In CBCToken.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In Bank.fallback, it can be over/underflowed. check your logic: EXPRESSION payoutCBC = calculateCBCPrize(msg.sender)
 In ExchangeRate.updateRates, it can be over/underflowed. check your logic: NEW VARIABLE symbol = bytes32(data[i * 2])
 In Authorizable.addAuthorized, it can be over/underflowed. check your logic: EXPRESSION authorizers.length ++
 In Bank.fallback, it can be over/underflowed. check your logic: EXPRESSION payout = calculateETHPrize(msg.sender)
 In MainSale.getAuthorizer, it can be over/underflowed. check your logic: RETURN address(authorizers[authorizerIndex + 1])
 In Bank.setInfo, it can be over/underflowed. check your logic: EXPRESSION calculateProbability()
 
line_number: 615
line_number: 617
line_number: 660
line_number: 662
line_number: 664
line_number: 727
line_number: 729

Filename: 0xdc2b59ae20b5ea70557cf053de990f997f32640b_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
TokenERC20.slitherConstructorConstantVariables() (0xdc2b59ae20b5ea70557cf053de990f997f32640b_integerOverflow.sol#58-322) uses literals with too many digits: 700000000000000000 recommended suffix: finney
	- totalsupply_ = 700000000000000000 (0xdc2b59ae20b5ea70557cf053de990f997f32640b_integerOverflow.sol#71)
 check: over-underflow
impact: Low
confidence: Low
description
In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[contain - 1].address_lock = address_lock
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[contain - 1].lockEndTime = lockEndTime
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In TokenERC20.getTimeAddressLock, it can be over/underflowed. check your logic: RETURN (lockbox_address_arr[contain - 1].address_lock,lockbox_address_arr[contain - 1].lockStartTime,lockbox_address_arr[contain - 1].lockEndTime,contain - 1,lockbox_address_arr.length)
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[lockbox_address_arr.length - 1].address_lock = address_lock
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In TokenERC20.getTimeAddressLock, it can be over/underflowed. check your logic: NEW VARIABLE contain = isExitLockAddress(address_)
 In TokenERC20.isExitLockAddress, it can be over/underflowed. check your logic: RETURN isExist = i + 1
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[lockbox_address_arr.length - 1].lockStartTime = lockStartTime
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: NEW VARIABLE contain = isExitLockAddress(address_lock)
 In TokenERC20.isExitLockAddress, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr.length ++
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[contain - 1].lockStartTime = lockStartTime
 In TokenERC20.lock_address_erc, it can be over/underflowed. check your logic: EXPRESSION lockbox_address_arr[lockbox_address_arr.length - 1].lockEndTime = lockEndTime
 
line_number: 184

Filename: 0xdcc27bbaa14cafd8a6aeb847e1b01c5dffb70935_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
VantaToken.slitherConstructorConstantVariables() (0xdcc27bbaa14cafd8a6aeb847e1b01c5dffb70935_integerOverflow.sol#124-534) uses literals with too many digits: 1000000000000000000 recommended suffix: ether
	- E18 = 1000000000000000000 (0xdcc27bbaa14cafd8a6aeb847e1b01c5dffb70935_integerOverflow.sol#132)
 check: over-underflow
impact: Low
confidence: Low
description
In VantaToken.bdevIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxTotalSupply = 56200000000 * E18
 In VantaToken.mktIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT advisorVestingDate = 3 * month
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In VantaToken.withdrawTokens, it can be over/underflowed. check your logic: NEW VARIABLE eth = _value.mul(10 ** _decimals)
 In VantaToken.balanceOf, it can be over/underflowed. check your logic: EXPRESSION balance = balance.add(privateFirstWallet[_who] + privateSecondWallet[_who])
 In VantaToken.privateUnlock, it can be over/underflowed. check your logic: IF (time >= endSaleTime.add(month * 2)) && (privateSecondWallet[_to] > 0)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In VantaToken.reserveIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.endSale, it can be over/underflowed. check your logic: EXPRESSION i ++
 In VantaToken.advisorIssueVesting, it can be over/underflowed. check your logic: EXPRESSION require(bool)(((endSaleTime + (_time * advisorVestingDate)) < time) && (advisorVestingTimeAtSupply[_time] > 0))
 In VantaToken.burnToken, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxMktSupply = 8430000000 * E18
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxRndSupply = 8430000000 * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT advisorVestingSupplyPerTime = 702500000 * E18
 In VantaToken.privateIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxReserveSupply = 2810000000 * E18
 In VantaToken.endSale, it can be over/underflowed. check your logic: EXPRESSION i_scope_0 ++
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT teamVestingSupplyPerTime = 351250000 * E18
 In VantaToken.publicIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.constructor, it can be over/underflowed. check your logic: EXPRESSION require(bool)(maxTotalSupply == maxSaleSupply + maxBdevSupply + maxMktSupply + maxRndSupply + maxTeamSupply + maxReserveSupply + maxAdvisorSupply)
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT teamVestingDate = 2 * month
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxTeamSupply = 5620000000 * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxSaleSupply = 19670000000 * E18
 In VantaToken.constructor, it can be over/underflowed. check your logic: EXPRESSION require(bool)(maxAdvisorSupply == advisorVestingSupplyPerTime * advisorVestingTime)
 In VantaToken.withdrawTokens, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value.mul(10 ** _decimals)
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxBdevSupply = 8430000000 * E18
 In VantaToken.teamIssueVesting, it can be over/underflowed. check your logic: EXPRESSION require(bool)(((endSaleTime + (_time * teamVestingDate)) < time) && (teamVestingTimeAtSupply[_time] > 0))
 In VantaToken.rndIssue, it can be over/underflowed. check your logic: NEW VARIABLE tokens = _value * E18
 In VantaToken.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT maxAdvisorSupply = 2810000000 * E18
 In VantaToken.constructor, it can be over/underflowed. check your logic: EXPRESSION require(bool)(maxTeamSupply == teamVestingSupplyPerTime * teamVestingTime)
 
line_number: 235
line_number: 268

Filename: 0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
SwapdexPair._update(uint256,uint256,uint112,uint112) (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#273-286) uses literals with too many digits: 32 recommended suffix: ether
	- blockTimestamp = uint32(block.timestamp % 2 ** 32) (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#275)
 UQ112x112.slitherConstructorConstantVariables() (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#491-504) uses literals with too many digits: 112 recommended suffix: ether
	- Q112 = 2 ** 112 (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#492)
 SwapdexPair.slitherConstructorConstantVariables() (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#211-401) uses literals with too many digits: 3 recommended suffix: gwei
	- MINIMUM_LIQUIDITY = 10 ** 3 (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#215)
 SwapdexPair.swap(uint256,uint256,address,bytes) (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#359-387) uses literals with too many digits: 2 recommended suffix: gwei
	- require(bool,string)(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),Swapdex: K) (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#382)
 SwapdexFactory.createPair(address,address) (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#420-435) uses literals with too many digits: 60806040526001600c5534801561001557600080fd5b5060004690506040518080613b5860529139605201905060405180910390206040518060400160405280600781526020017f5377617064657800000000000000000000000000000000000000000000000000815250805190602001206040518060400160405280600181526020017f3100000000000000000000000000000000000000000000000000000000000000815250805190602001208330604051602001808681526020018581526020018481526020018381526020018273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200195505050505050604051602081830303815290604052805190602001206003819055505033600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506139e3806101756000396000f3fe608060405234801561001057600080fd5b50600436106101a95760003560e01c80636a627842116100f9578063ba9a7a5611610097578063d21220a711610071578063d21220a7146108c4578063d505accf1461090e578063dd62ed3e146109a7578063fff6cae914610a1f576101a9565b8063ba9a7a5614610818578063bc25cf7714610836578063c45a01551461087a576101a9565b80637ecebe00116100d35780637ecebe001461067857806389afcb44146106d057806395d89b411461072f578063a9059cbb146107b2576101a9565b80636a627842146105aa57806370a08231146106025780637464fc3d1461065a576101a9565b806323b872dd116101665780633644e515116101405780633644e515146104ec578063485cc9551461050a5780635909c0d51461056e5780635a3d54931461058c576101a9565b806323b872dd1461042457806330adf81f146104aa578063313ce567146104c8576101a9565b8063022c0d9f146101ae57806306fdde031461025b5780630902f1ac146102de578063095ea7b3146103565780630dfe1681146103bc57806318160ddd14610406575b600080fd5b610259600480360360808110156101c457600080fd5b810190808035906020019092919080359060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019064010000000081111561021557600080fd5b82018360208201111561022757600080fd5b8035906020019184600183028401116401000000008311171561024957600080fd5b9091929391929390505050610a29565b005b610263611233565b6040518080602001828103825283818151815260200191508051906020019080838360005b838110156102a3578082015181840152602081019050610288565b50505050905090810190601f1680156102d05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6102e661126c565b60405180846dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152602001836dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1681526020018263ffffffff1663ffffffff168152602001935050505060405180910390f35b6103a26004803603604081101561036c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506112c9565b604051808215151515815260200191505060405180910390f35b6103c46112e0565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b61040e611306565b6040518082815260200191505060405180910390f35b6104906004803603606081101561043a57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061130c565b604051808215151515815260200191505060405180910390f35b6104b26114d7565b6040518082815260200191505060405180910390f35b6104d06114fe565b604051808260ff1660ff16815260200191505060405180910390f35b6104f4611503565b6040518082815260200191505060405180910390f35b61056c6004803603604081101561052057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611509565b005b610576611652565b6040518082815260200191505060405180910390f35b610594611658565b6040518082815260200191505060405180910390f35b6105ec600480360360208110156105c057600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919050505061165e565b6040518082815260200191505060405180910390f35b6106446004803603602081101561061857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611b0f565b6040518082815260200191505060405180910390f35b610662611b27565b6040518082815260200191505060405180910390f35b6106ba6004803603602081101561068e57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611b2d565b6040518082815260200191505060405180910390f35b610712600480360360208110156106e657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611b45565b604051808381526020018281526020019250505060405180910390f35b610737612132565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561077757808201518184015260208101905061075c565b50505050905090810190601f1680156107a45780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6107fe600480360360408110156107c857600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061216b565b604051808215151515815260200191505060405180910390f35b610820612182565b6040518082815260200191505060405180910390f35b6108786004803603602081101561084c57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050612188565b005b610882612463565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6108cc612489565b604051808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060405180910390f35b6109a5600480360360e081101561092457600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919080359060200190929190803560ff16906020019092919080359060200190929190803590602001909291905050506124af565b005b610a09600480360360408110156109bd57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506127f3565b6040518082815260200191505060405180910390f35b610a27612818565b005b6001600c5414610aa1576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f537761706465783a204c4f434b4544000000000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000851180610ab85750600084115b610b0d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252602381526020018061391e6023913960400191505060405180910390fd5b600080610b1861126c565b5091509150816dffffffffffffffffffffffffffff1687108015610b4b5750806dffffffffffffffffffffffffffff1686105b610bbd576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601f8152602001807f537761706465783a20494e53554646494349454e545f4c49515549444954590081525060200191505060405180910390fd5b6000806000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508173ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614158015610c7657508073ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff1614155b610ce8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260138152602001807f537761706465783a20494e56414c49445f544f0000000000000000000000000081525060200191505060405180910390fd5b60008b1115610cfd57610cfc828a8d612a98565b5b60008a1115610d1257610d11818a8c612a98565b5b6000888890501115610dfa578873ffffffffffffffffffffffffffffffffffffffff166386341232338d8d8c8c6040518663ffffffff1660e01b8152600401808673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001858152602001848152602001806020018281038252848482818152602001925080828437600081840152601f19601f8201169050808301925050509650505050505050600060405180830381600087803b158015610de157600080fd5b505af1158015610df5573d6000803e3d6000fd5b505050505b8173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610e7757600080fd5b505afa158015610e8b573d6000803e3d6000fd5b505050506040513d6020811015610ea157600080fd5b810190808051906020019092919050505093508073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015610f3157600080fd5b505afa158015610f45573d6000803e3d6000fd5b505050506040513d6020811015610f5b57600080fd5b810190808051906020019092919050505092505050600089856dffffffffffffffffffffffffffff16038311610f92576000610fa8565b89856dffffffffffffffffffffffffffff160383035b9050600089856dffffffffffffffffffffffffffff16038311610fcc576000610fe2565b89856dffffffffffffffffffffffffffff160383035b90506000821180610ff35750600081115b611048576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260228152602001806139416022913960400191505060405180910390fd5b6000611084611061600385612ce590919063ffffffff16565b6110766103e888612ce590919063ffffffff16565b612d7a90919063ffffffff16565b905060006110c261109f600385612ce590919063ffffffff16565b6110b46103e888612ce590919063ffffffff16565b612d7a90919063ffffffff16565b905061110c620f42406110fe896dffffffffffffffffffffffffffff168b6dffffffffffffffffffffffffffff16612ce590919063ffffffff16565b612ce590919063ffffffff16565b61111f8284612ce590919063ffffffff16565b1015611193576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600a8152602001807f537761706465783a204b0000000000000000000000000000000000000000000081525060200191505060405180910390fd5b50506111a184848888612d82565b8873ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fd78ad95fa46c994b6551d0da85fc275fe613ce37657fb8d5e3d130840159d82284848f8f6040518085815260200184815260200183815260200182815260200194505050505060405180910390a35050505050506001600c819055505050505050565b6040518060400160405280600781526020017f537761706465780000000000000000000000000000000000000000000000000081525081565b6000806000600860009054906101000a90046dffffffffffffffffffffffffffff1692506008600e9054906101000a90046dffffffffffffffffffffffffffff1691506008601c9054906101000a900463ffffffff169050909192565b60006112d6338484613100565b6001905092915050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60005481565b60007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054146114c15761144082600260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d7a90919063ffffffff16565b600260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b6114cc8484846131eb565b600190509392505050565b7f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c960001b81565b601281565b60035481565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146115cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260128152602001807f537761706465783a20464f5242494444454e000000000000000000000000000081525060200191505060405180910390fd5b81600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555080600760006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055505050565b60095481565b600a5481565b60006001600c54146116d8576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f537761706465783a204c4f434b4544000000000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000806116eb61126c565b50915091506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561179157600080fd5b505afa1580156117a5573d6000803e3d6000fd5b505050506040513d60208110156117bb57600080fd5b810190808051906020019092919050505090506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561186f57600080fd5b505afa158015611883573d6000803e3d6000fd5b505050506040513d602081101561189957600080fd5b8101908080519060200190929190505050905060006118d1856dffffffffffffffffffffffffffff1684612d7a90919063ffffffff16565b905060006118f8856dffffffffffffffffffffffffffff1684612d7a90919063ffffffff16565b90506000611906878761337f565b9050600080549050600081141561195a576119466103e86119386119338688612ce590919063ffffffff16565b613560565b612d7a90919063ffffffff16565b985061195560006103e86135c2565b6119bd565b6119ba886dffffffffffffffffffffffffffff166119818387612ce590919063ffffffff16565b8161198857fe5b04886dffffffffffffffffffffffffffff166119ad8487612ce590919063ffffffff16565b816119b457fe5b046136dc565b98505b60008911611a16576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001806139636026913960400191505060405180910390fd5b611a208a8a6135c2565b611a2c86868a8a612d82565b8115611aa457611a9d6008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16612ce590919063ffffffff16565b600b819055505b3373ffffffffffffffffffffffffffffffffffffffff167f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f8585604051808381526020018281526020019250505060405180910390a250505050505050506001600c81905550919050565b60016020528060005260406000206000915090505481565b600b5481565b60046020528060005260406000206000915090505481565b6000806001600c5414611bc0576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f537761706465783a204c4f434b4544000000000000000000000000000000000081525060200191505060405180910390fd5b6000600c81905550600080611bd361126c565b50915091506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611ca557600080fd5b505afa158015611cb9573d6000803e3d6000fd5b505050506040513d6020811015611ccf57600080fd5b8101908080519060200190929190505050905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611d6157600080fd5b505afa158015611d75573d6000803e3d6000fd5b505050506040513d6020811015611d8b57600080fd5b810190808051906020019092919050505090506000600160003073ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506000611dee888861337f565b905060008054905080611e0a8685612ce590919063ffffffff16565b81611e1157fe5b049a5080611e288585612ce590919063ffffffff16565b81611e2f57fe5b04995060008b118015611e42575060008a115b611e97576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260268152602001806139896026913960400191505060405180910390fd5b611ea130846136f5565b611eac878d8d612a98565b611eb7868d8c612a98565b8673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611f3457600080fd5b505afa158015611f48573d6000803e3d6000fd5b505050506040513d6020811015611f5e57600080fd5b810190808051906020019092919050505094508573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015611fee57600080fd5b505afa158015612002573d6000803e3d6000fd5b505050506040513d602081101561201857600080fd5b8101908080519060200190929190505050935061203785858b8b612d82565b81156120af576120a86008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff16612ce590919063ffffffff16565b600b819055505b8b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167fdccd412f0b1252819cb1fd330b93224ca42612892bb3f4f789976e6d819364968d8d604051808381526020018281526020019250505060405180910390a35050505050505050506001600c81905550915091565b6040518060400160405280600381526020017f534458000000000000000000000000000000000000000000000000000000000081525081565b60006121783384846131eb565b6001905092915050565b6103e881565b6001600c5414612200576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f537761706465783a204c4f434b4544000000000000000000000000000000000081525060200191505060405180910390fd5b6000600c819055506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506123568284612351600860009054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561230857600080fd5b505afa15801561231c573d6000803e3d6000fd5b505050506040513d602081101561233257600080fd5b8101908080519060200190929190505050612d7a90919063ffffffff16565b612a98565b61245681846124516008600e9054906101000a90046dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561240857600080fd5b505afa15801561241c573d6000803e3d6000fd5b505050506040513d602081101561243257600080fd5b8101908080519060200190929190505050612d7a90919063ffffffff16565b612a98565b50506001600c8190555050565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b42841015612525576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260108152602001807f537761706465783a20455850495245440000000000000000000000000000000081525060200191505060405180910390fd5b60006003547f6e71edae12b1b97f4d1f60370fef10105fa2faae0126114a169c64845d6126c960001b898989600460008e73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000815480929190600101919050558a604051602001808781526020018673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200184815260200183815260200182815260200196505050505050506040516020818303038152906040528051906020012060405160200180807f190100000000000000000000000000000000000000000000000000000000000081525060020183815260200182815260200192505050604051602081830303815290604052805190602001209050600060018286868660405160008152602001604052604051808581526020018460ff1660ff1681526020018381526020018281526020019450505050506020604051602081039080840390855afa1580156126f7573d6000803e3d6000fd5b505050602060405103519050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415801561276b57508873ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16145b6127dd576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252601a8152602001807f537761706465783a20494e56414c49445f5349474e415455524500000000000081525060200191505060405180910390fd5b6127e8898989613100565b505050505050505050565b6002602052816000526040600020602052806000526040600020600091509150505481565b6001600c5414612890576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040180806020018281038252600f8152602001807f537761706465783a204c4f434b4544000000000000000000000000000000000081525060200191505060405180910390fd5b6000600c81905550612a8e600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b15801561293a57600080fd5b505afa15801561294e573d6000803e3d6000fd5b505050506040513d602081101561296457600080fd5b8101908080519060200190929190505050600760009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401808273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200191505060206040518083038186803b158015612a1457600080fd5b505afa158015612a28573d6000803e3d6000fd5b505050506040513d6020811015612a3e57600080fd5b8101908080519060200190929190505050600860009054906101000a90046dffffffffffffffffffffffffffff166008600e9054906101000a90046dffffffffffffffffffffffffffff16612d82565b6001600c81905550565b600060608473ffffffffffffffffffffffffffffffffffffffff166040518060400160405280601981526020017f7472616e7366657228616464726573732c75696e743235362900000000000000815250805190602001208585604051602401808373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200182815260200192505050604051602081830303815290604052907bffffffffffffffffffffffffffffffffffffffffffffffffffffffff19166020820180517bffffffffffffffffffffffffffffffffffffffffffffffffffffffff83818316178352505050506040518082805190602001908083835b60208310612bc55780518252602082019150602081019050602083039250612ba2565b6001836020036101000a0380198251168184511680821785525050505050509050019150506000604051808303816000865af19150503d8060008114612c27576040519150601f19603f3d011682016040523d82523d6000602084013e612c2c565b606091505b5091509150818015612c6c5750600081511480612c6b5750808060200190516020811015612c5957600080fd5b81019080805190602001909291905050505b5b612cde576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260188152602001807f537761706465783a205452414e534645525f4641494c4544000000000000000081525060200191505060405180910390fd5b5050505050565b600080821480612d025750828283850292508281612cff57fe5b04145b612d74576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6d756c2d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b92915050565b600092915050565b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6dffffffffffffffffffffffffffff168411158015612df257507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff6dffffffffffffffffffffffffffff168311155b612e64576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260118152602001807f537761706465783a204f564552464c4f5700000000000000000000000000000081525060200191505060405180910390fd5b60006401000000004281612e7457fe5b06905060006008601c9054906101000a900463ffffffff168203905060008163ffffffff16118015612eb757506000846dffffffffffffffffffffffffffff1614155b8015612ed457506000836dffffffffffffffffffffffffffff1614155b15612fb6578063ffffffff16612f1985612eed8661380f565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1661383a90919063ffffffff16565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16026009600082825401925050819055508063ffffffff16612f8784612f5b8761380f565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1661383a90919063ffffffff16565b7bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602600a600082825401925050819055505b85600860006101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff160217905550846008600e6101000a8154816dffffffffffffffffffffffffffff02191690836dffffffffffffffffffffffffffff160217905550816008601c6101000a81548163ffffffff021916908363ffffffff1602179055507f1c411e9a96e071241c2f21f7726b17ae89e3cab4c78be50e062b03a9fffbbad1600860009054906101000a90046dffffffffffffffffffffffffffff166008600e9054906101000a90046dffffffffffffffffffffffffffff1660405180836dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff168152602001826dffffffffffffffffffffffffffff166dffffffffffffffffffffffffffff1681526020019250505060405180910390a1505050505050565b80600260008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925836040518082815260200191505060405180910390a3505050565b61323d81600160008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d7a90919063ffffffff16565b600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506132d281600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461389a90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a3505050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663017e7e586040518163ffffffff1660e01b815260040160206040518083038186803b1580156133ea57600080fd5b505afa1580156133fe573d6000803e3d6000fd5b505050506040513d602081101561341457600080fd5b81019080805190602001909291905050509050600073ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff16141591506000600b549050821561354657600081146135415760006134ac6134a7866dffffffffffffffffffffffffffff16886dffffffffffffffffffffffffffff16612ce590919063ffffffff16565b613560565b905060006134b983613560565b90508082111561353e5760006134ec6134db8385612d7a90919063ffffffff16565b600054612ce590919063ffffffff16565b9050600061351683613508600587612ce590919063ffffffff16565b61389a90919063ffffffff16565b9050600081838161352357fe5b049050600081111561353a5761353987826135c2565b5b5050505b50505b613558565b60008114613557576000600b819055505b5b505092915050565b600060038211156135af57819050600060016002848161357c57fe5b040190505b818110156135a95780915060028182858161359857fe5b0401816135a157fe5b049050613581565b506135bd565b600082146135bc57600190505b5b919050565b6135d78160005461389a90919063ffffffff16565b60008190555061362f81600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461389a90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff16600073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35050565b60008183106136eb57816136ed565b825b905092915050565b61374781600160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612d7a90919063ffffffff16565b600160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555061379f81600054612d7a90919063ffffffff16565b600081905550600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef836040518082815260200191505060405180910390a35050565b60006e010000000000000000000000000000826dffffffffffffffffffffffffffff16029050919050565b6000816dffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff16837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168161389157fe5b04905092915050565b6000828284019150811015613917576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004018080602001828103825260148152602001807f64732d6d6174682d6164642d6f766572666c6f7700000000000000000000000081525060200191505060405180910390fd5b9291505056fe537761706465783a20494e53554646494349454e545f4f55545055545f414d4f554e54537761706465783a20494e53554646494349454e545f494e5055545f414d4f554e54537761706465783a20494e53554646494349454e545f4c49515549444954595f4d494e544544537761706465783a20494e53554646494349454e545f4c49515549444954595f4255524e4544a265627a7a723158205d434820c756dfdcedcbf6866c896e9e8b6af053143a7705347a16051feac74964736f6c63430005100032454950373132446f6d61696e28737472696e67206e616d652c737472696e672076657273696f6e2c75696e7432353620636861696e49642c6164647265737320766572696679696e67436f6e747261637429 recommended suffix: ether
	- bytecode = type(address)(SwapdexPair).creationCode (0xdfcc3668a5d426114270ee57206e98c6856f3dee_integerOverflow.sol#425)
 check: over-underflow
impact: Low
confidence: Low
description
In SwapdexPair.burn, it can be over/underflowed. check your logic: NEW VARIABLE feeOn = _mintFee(_reserve0,_reserve1)
 In SwapdexPair.swap, it can be over/underflowed. check your logic: EXPRESSION amount0In = balance0 - (_reserve0 - amount0Out)
 In SwapdexPair.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT MINIMUM_LIQUIDITY = 10 ** 3
 In UQ112x112.encode, it can be over/underflowed. check your logic: EXPRESSION z = uint224(y) * Q112
 In SwapdexPair.swap, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balance0Adjusted.mul(balance1Adjusted) >= uint256(_reserve0).mul(_reserve1).mul(1000 ** 2),Swapdex: K)
 In SwapdexPair.burn, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In SwapdexPair._update, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(balance0 <= uint112(- 1) && balance1 <= uint112(- 1),Swapdex: OVERFLOW)
 In SwapdexPair._update, it can be over/underflowed. check your logic: NEW VARIABLE blockTimestamp = uint32(block.timestamp % 2 ** 32)
 In SwapdexPair._mintFee, it can be over/underflowed. check your logic: EXPRESSION _mint(feeTo,liquidity)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)((z = x + y) >= x,ds-math-add-overflow)
 In SwapdexPair.sync, it can be over/underflowed. check your logic: EXPRESSION _update(IERC20(token0).balanceOf(address(this)),IERC20(token1).balanceOf(address(this)),reserve0,reserve1)
 In SwapdexPair._update, it can be over/underflowed. check your logic: EXPRESSION price0CumulativeLast += uint256(UQ112x112.encode(_reserve1).uqdiv(_reserve0)) * timeElapsed
 In SwapdexPair.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SwapdexPair.swap, it can be over/underflowed. check your logic: IF balance0 > _reserve0 - amount0Out
 In SwapdexPair.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In Math.sqrt, it can be over/underflowed. check your logic: NEW VARIABLE x = y / 2 + 1
 In UQ112x112.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT Q112 = 2 ** 112
 In SwapdexERC20.permit, it can be over/underflowed. check your logic: NEW VARIABLE digest = keccak256(bytes)(abi.encodePacked(,DOMAIN_SEPARATOR,keccak256(bytes)(abi.encode(PERMIT_TYPEHASH,owner,spender,value,nonces[owner] ++,deadline))))
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(y == 0 || (z = x * y) / y == x,ds-math-mul-overflow)
 In SwapdexPair.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(address(0),MINIMUM_LIQUIDITY)
 In SwapdexPair.swap, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In SwapdexPair.swap, it can be over/underflowed. check your logic: EXPRESSION amount1In = balance1 - (_reserve1 - amount1Out)
 In Math.sqrt, it can be over/underflowed. check your logic: EXPRESSION x = (y / x + x) / 2
 In SwapdexPair.mint, it can be over/underflowed. check your logic: NEW VARIABLE feeOn = _mintFee(_reserve0,_reserve1)
 In SwapdexPair._update, it can be over/underflowed. check your logic: EXPRESSION price1CumulativeLast += uint256(UQ112x112.encode(_reserve0).uqdiv(_reserve1)) * timeElapsed
 In SwapdexERC20.transferFrom, it can be over/underflowed. check your logic: IF allowance[from][msg.sender] != uint256(- 1)
 In SwapdexPair.mint, it can be over/underflowed. check your logic: EXPRESSION _update(balance0,balance1,_reserve0,_reserve1)
 In SwapdexPair.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SwapdexPair.swap, it can be over/underflowed. check your logic: IF balance1 > _reserve1 - amount1Out
 In SwapdexPair.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(to,liquidity)
 In SwapdexFactory.createPair, it can be over/underflowed. check your logic: EXPRESSION allPairs.push(pair)
 In SwapdexERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(from,to,value)
 In SwapdexPair._update, it can be over/underflowed. check your logic: NEW VARIABLE timeElapsed = blockTimestamp - blockTimestampLast
 In SwapdexERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,to,value)
 In SwapdexPair.transferFrom, it can be over/underflowed. check your logic: IF allowance[from][msg.sender] != uint256(- 1)
 
line_number: 189

Filename: 0xe3e5ccc9c8ee95ddbeb08daa7c5001b88c0d632a_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In BangkaToken.burnFrom, it can be over/underflowed. check your logic: EXPRESSION assert(bool)(transferFrom(_from,msg.sender,_value))
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In BangkaToken.burnFrom, it can be over/underflowed. check your logic: RETURN burn(_value)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In BangkaToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In BangkaToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In BangkaToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In BangkaToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 
line_number: 63
line_number: 75
line_number: 115
line_number: 126
line_number: 247
line_number: 249

Filename: 0xe80b90fdabcc18932e2bcda61df6010df69091c7_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
CryptoControlToken.constructor() (0xe80b90fdabcc18932e2bcda61df6010df69091c7_integerOverflow.sol#426) uses literals with too many digits: 10000000000000000000 recommended suffix: ether
	- CappedToken(10000000000000000000) (0xe80b90fdabcc18932e2bcda61df6010df69091c7_integerOverflow.sol#426)
 check: over-underflow
impact: Low
confidence: Low
description
In UpgradedStandardToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In CryptoControlToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In PausableToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = _a * _b
 In PausableToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In CryptoControlToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In UpgradedStandardToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 In CryptoControlToken.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In UpgradedStandardToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = _a + _b
 In PausableToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In UpgradedStandardToken.decreaseApproval, it can be over/underflowed. check your logic: RETURN super.decreaseApproval(_spender,_subtractedValue)
 In CryptoControlToken.approve, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In PausableToken.transfer, it can be over/underflowed. check your logic: RETURN super.transfer(_to,_value)
 In CappedToken.mint, it can be over/underflowed. check your logic: RETURN super.mint(_to,_amount)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN _a - _b
 In CryptoControlToken.increaseApproval, it can be over/underflowed. check your logic: RETURN super.increaseApproval(_spender,_addedValue)
 In CryptoControlToken.transferFrom, it can be over/underflowed. check your logic: RETURN super.transferFrom(_from,_to,_value)
 
line_number: 178
line_number: 219
line_number: 286
line_number: 309
line_number: 343
line_number: 345

Filename: 0xeaddd1db4fe9d8fd2a0edfd59521b7e7c57cfa3e_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In master.airdrop, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In master.airdrop, it can be over/underflowed. check your logic: EXPRESSION require(bool)(transferFrom(source,dests[i],values[i]))
 In master.burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In SafeMath.ceil, it can be over/underflowed. check your logic: RETURN mul(div(d,m),m)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In master.burn, it can be over/underflowed. check your logic: EXPRESSION _burn(msg.sender,amount)
 In SafeMath.ceil, it can be over/underflowed. check your logic: NEW VARIABLE c = add(a,m)
 In SafeMath.ceil, it can be over/underflowed. check your logic: NEW VARIABLE d = sub(c,1)
 In master.slitherConstructorVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _totalSupply = 20000000 * 100000000
 
line_number: 119
line_number: 182

Filename: 0xecf8c26e45eebd78ca4577f319b9db198089b935_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
AOLibrary.slitherConstructorConstantVariables() (0xecf8c26e45eebd78ca4577f319b9db198089b935_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _PERCENTAGE_DIVISOR = 10 ** 6 (0xecf8c26e45eebd78ca4577f319b9db198089b935_integerOverflow.sol#344)
 AOLibrary.slitherConstructorConstantVariables() (0xecf8c26e45eebd78ca4577f319b9db198089b935_integerOverflow.sol#340-642) uses literals with too many digits: 6 recommended suffix: gwei
	- _MULTIPLIER_DIVISOR = 10 ** 6 (0xecf8c26e45eebd78ca4577f319b9db198089b935_integerOverflow.sol#343)
 check: over-underflow
impact: Low
confidence: Low
description
In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _MULTIPLIER_DIVISOR = 10 ** 6
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION require(bool)(balanceOf[_to] + _value > balanceOf[_to])
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In AOLibrary.slitherConstructorConstantVariables, it can be over/underflowed. check your logic: OTHER_ENTRYPOINT _PERCENTAGE_DIVISOR = 10 ** 6
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In EthosExa.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In TokenERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(msg.sender,_to,_value)
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION allowance[_from][msg.sender] -= _value
 In AOLibrary.numDigits, it can be over/underflowed. check your logic: EXPRESSION digits ++
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION totalSupply -= _value
 In TokenERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_to] += _value
 In TokenERC20.burnFrom, it can be over/underflowed. check your logic: EXPRESSION balanceOf[_from] -= _value
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TokenERC20.burn, it can be over/underflowed. check your logic: EXPRESSION balanceOf[msg.sender] -= _value
 In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION totalSupply = initialSupply * 10 ** uint256(decimals)
 In TAOCurrency.mint, it can be over/underflowed. check your logic: EXPRESSION _mint(target,mintedAmount)
 In AOLibrary.calculateNetworkBonusAmount, it can be over/underflowed. check your logic: NEW VARIABLE bonusPercentage = calculateNetworkBonusPercentage(_purchaseAmount,_totalPrimordialMintable,_totalPrimordialMinted,_startingMultiplier,_endingMultiplier)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: NEW VARIABLE previousBalances = balanceOf[_from] + balanceOf[_to]
 In EthosExa.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 In TokenERC20._transfer, it can be over/underflowed. check your logic: EXPRESSION assert(bool)(balanceOf[_from] + balanceOf[_to] == previousBalances)
 In TAOCurrency.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(_from,_to,_value)
 
line_number: 815

Filename: 0xf57d52855ca38228cf37c0ba0fc4f98845e16c4c_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
GoldenCoinP.constructor() (0xf57d52855ca38228cf37c0ba0fc4f98845e16c4c_integerOverflow.sol#117-124) uses literals with too many digits: 777000000000000000000000000000 recommended suffix: ether
	- totalSupply = 777000000000000000000000000000 (0xf57d52855ca38228cf37c0ba0fc4f98845e16c4c_integerOverflow.sol#118)
 check: over-underflow
impact: Low
confidence: Low
description
In ERC20Standard.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In GoldenCoinP.transfer, it can be over/underflowed. check your logic: EXPRESSION onlyPayloadSize(2 * 32)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 
line_number: 78
line_number: 85

Filename: 0xf7914ebf0f021adaf95114b068502d0c7d107bc9_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In TellorDispute.beginDispute, it can be over/underflowed. check your logic: NEW VARIABLE disputeId = self.uintVars[keccak256(bytes)(disputeCount)] + 1
 In Utilities.getMin, it can be over/underflowed. check your logic: NEW VARIABLE i = data.length - 2
 In TellorLibrary._submitMiningSolution, it can be over/underflowed. check your logic: IF _slotProgress + 1 == 5
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _tblock.minersByValue[k][j] = _tblock.minersByValue[k][j - 1]
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION TellorTransfer.doTransfer(self,address(this),miners[1],reward + _tip)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: NEW VARIABLE timeDiff = now - self.uintVars[timeOfLastNewValue]
 In TellorDispute.proposeFork, it can be over/underflowed. check your logic: EXPRESSION self.disputesById[disputeId].disputeUintVars[keccak256(bytes)(minExecutionDate)] = now + 604800
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: NEW VARIABLE dispRounds = self.disputesById[origID].disputeUintVars[keccak256(bytes)(disputeRounds)] + 1
 In Utilities.getMax5, it can be over/underflowed. check your logic: EXPRESSION maxIndex[j] = j + 1
 In TellorDispute.proposeFork, it can be over/underflowed. check your logic: NEW VARIABLE lastID = self.disputesById[origID].disputeUintVars[keccak256(bytes)(abi.encode(dispRounds - 1))]
 In TellorStake.requestStakingWithdraw, it can be over/underflowed. check your logic: EXPRESSION stakes.startDate = now - (now % 86400)
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: EXPRESSION previousBalance = balanceOf(self,_to)
 In TellorStake.newStake, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[keccak256(bytes)(stakerCount)] += 1
 In TellorTransfer.balanceOf, it can be over/underflowed. check your logic: RETURN balanceOfAt(self,_user,block.number)
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: EXPRESSION _fee = self.uintVars[keccak256(bytes)(disputeFee)] * dispRounds
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[keccak256(bytes)(stakerCount)] -= 1
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: EXPRESSION updateBalanceAtNow(self.balances[_from],previousBalance - _amount)
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: NEW VARIABLE lastID = self.disputesById[origID].disputeUintVars[keccak256(bytes)(abi.encode(dispRounds - 1))]
 In TellorGettersLibrary.getVariablesOnDeck, it can be over/underflowed. check your logic: NEW VARIABLE newRequestId = getTopRequestID(self)
 In TellorLibrary._submitMiningSolution, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[slotProgress] ++
 In TellorGettersLibrary.getLastNewValueById, it can be over/underflowed. check your logic: RETURN (retrieveData(self,_requestId,_request.requestTimestamps[_request.requestTimestamps.length - 1]),true)
 In TellorDispute.tallyVotes, it can be over/underflowed. check your logic: IF uint256(_tally) >= ((self.uintVars[keccak256(bytes)(total_supply)] * 10) / 100)
 In TellorTransfer.balanceOfAt, it can be over/underflowed. check your logic: NEW VARIABLE mid = (max + min + 1) / 2
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorTransfer.allowedToTrade, it can be over/underflowed. check your logic: IF balanceOf(self,_user) - self.uintVars[stakeAmount] >= _amount
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION _id = disp.disputeUintVars[keccak256(bytes)(abi.encode(dispRounds - i_scope_0))]
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION i_scope_0 ++
 In TellorStake.depositStake, it can be over/underflowed. check your logic: EXPRESSION newStake(self,msg.sender)
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION TellorTransfer.doTransfer(self,address(this),miners[2],reward + _tip)
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In TellorLibrary.submitMiningSolution, it can be over/underflowed. check your logic: EXPRESSION _verifyNonce(self,_nonce)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _request.requestTimestamps.push(_timeOfLastNewValue)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _tblock.valuesByTimestamp[k][j] = _tblock.valuesByTimestamp[k][j - 1]
 In TellorLibrary._submitMiningSolution, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - self.uintVars[_hashMsgSender] > 900,Miner can only win rewards once per 15 min)
 In Utilities.getMax5, it can be over/underflowed. check your logic: EXPRESSION j ++
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION self.requestDetails[disp.disputeUintVars[keccak256(bytes)(requestId)]].apiUintVars[keccak256(bytes)(disputeCount)] --
 In TellorStake.newStake, it can be over/underflowed. check your logic: EXPRESSION self.stakerDetails[staker] = TellorStorage.StakeInfo(1,now - (now % 86400))
 In TellorTransfer.transfer, it can be over/underflowed. check your logic: EXPRESSION doTransfer(self,msg.sender,_to,_amount)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION i_scope_0 ++
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION updateMinDisputeFee(self)
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In TellorTransfer.balanceOfAt, it can be over/underflowed. check your logic: IF _blockNumber >= checkpoints[checkpoints.length - 1].fromBlock
 In TellorStake.withdrawStake, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - (now % 86400) - stakes.startDate >= 604800,7 days didn't pass)
 In TellorDispute.proposeFork, it can be over/underflowed. check your logic: EXPRESSION self.disputesById[origID].disputeUintVars[keccak256(bytes)(disputeRounds)] ++
 In TellorLibrary.addTip, it can be over/underflowed. check your logic: EXPRESSION updateOnDeck(self,_requestId,_tip)
 In TellorLibrary._submitMiningSolution, it can be over/underflowed. check your logic: EXPRESSION newBlock(self,_nonce,_requestId)
 In TellorLibrary.updateOnDeck, it can be over/underflowed. check your logic: EXPRESSION self.requestQ[_request.apiUintVars[requestQPosition]] += _tip
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[total_supply] += _devShare + reward * 5 - (self.uintVars[currentTotalTips] / 2)
 In TellorDispute.proposeFork, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - self.disputesById[lastID].disputeUintVars[keccak256(bytes)(tallyDate)] <= 86400,Time for voting haven't elapsed)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION self.newValueTimestamps.push(_timeOfLastNewValue)
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION TellorTransfer.doTransfer(self,address(this),miners[0],reward + _tip)
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: EXPRESSION _fee = self.uintVars[keccak256(bytes)(stakeAmount)] * self.requestDetails[_requestId].apiUintVars[keccak256(bytes)(disputeCount)]
 In TellorLibrary.updateOnDeck, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[currentTotalTips] += _tip
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN a - b
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: EXPRESSION self.requestDetails[_requestId].apiUintVars[keccak256(bytes)(disputeCount)] = self.requestDetails[_requestId].apiUintVars[keccak256(bytes)(disputeCount)] + 1
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _currChallenge = keccak256(bytes)(abi.encode(_nonce,_currChallenge,blockhash(uint256)(block.number - 1)))
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION TellorTransfer.doTransfer(self,address(this),miners[4],reward + _tip)
 In Utilities.getMax5, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorTransfer.transferFrom, it can be over/underflowed. check your logic: EXPRESSION self.allowed[_from][msg.sender] -= _amount
 In Utilities.getMin, it can be over/underflowed. check your logic: EXPRESSION minIndex = data.length - 1
 In TellorDispute.updateMinDisputeFee, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[keccak256(bytes)(disputeFee)] = SafeMath.max(15e18,(stakeAmount - (stakeAmount * (SafeMath.min(targetMiners,self.uintVars[keccak256(bytes)(stakerCount)]) * 1000) / targetMiners) / 1000))
 In Utilities.getMax5, it can be over/underflowed. check your logic: EXPRESSION max[j] = data[j + 1]
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: NEW VARIABLE _timeOfLastNewValue = now - (now % 60)
 In TellorStake.getNewCurrentVariables, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[_tBlock] ++
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: EXPRESSION TellorTransfer.doTransfer(self,address(this),miners[3],reward + _tip)
 In TellorLibrary.addTip, it can be over/underflowed. check your logic: NEW VARIABLE _count = self.uintVars[requestCount] + 1
 In TellorTransfer.updateBalanceAtNow, it can be over/underflowed. check your logic: NEW VARIABLE oldCheckPoint = checkpoints[checkpoints.length - 1]
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - self.disputesById[lastID].disputeUintVars[keccak256(bytes)(tallyDate)] <= 86400,Time for voting haven't elapsed)
 In TellorTransfer.balanceOfAt, it can be over/underflowed. check your logic: NEW VARIABLE max = checkpoints.length - 2
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: IF_LOOP j > 0 && temp < _tblock.valuesByTimestamp[k][j - 1]
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION _id = disp.disputeUintVars[keccak256(bytes)(abi.encode(dispRounds - i))]
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[difficulty] = uint256(SafeMath.max(_diff + _change,1))
 In TellorStake.getTopRequestIDs, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(previousBalance + _amount >= previousBalance,Overflow happened)
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: EXPRESSION updateBalanceAtNow(self.balances[_to],previousBalance + _amount)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _change = (_diff * (int256(self.uintVars[timeTarget]) - _change)) / 4000
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION stakes.startDate = now - (now % 86400)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[currentTotalTips] += self.requestDetails[_topId[i_scope_0]].apiUintVars[totalTip]
 In TellorTransfer.updateBalanceAtNow, it can be over/underflowed. check your logic: EXPRESSION checkpoints.push(TellorStorage.Checkpoint(uint128(block.number),uint128(_value)))
 In TellorTransfer.allowedToTrade, it can be over/underflowed. check your logic: RETURN (balanceOf(self,_user) >= _amount)
 In TellorDispute.updateTellor, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - disp.disputeUintVars[keccak256(bytes)(tallyDate)] > 86400,Time for voting for further disputes has not passed)
 In Utilities.getMax, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorTransfer.transferFrom, it can be over/underflowed. check your logic: EXPRESSION doTransfer(self,_from,_to,_amount)
 In TellorStake.requestStakingWithdraw, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[keccak256(bytes)(stakerCount)] -= 1
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION k ++
 In TellorStake.getNewVariablesOnDeck, it can be over/underflowed. check your logic: EXPRESSION idsOnDeck = getTopRequestIDs(self)
 In TellorTransfer.balanceOfAt, it can be over/underflowed. check your logic: RETURN checkpoints[checkpoints.length - 1].value
 In TellorStake.getNewVariablesOnDeck, it can be over/underflowed. check your logic: EXPRESSION i ++
 In TellorDispute.beginDispute, it can be over/underflowed. check your logic: EXPRESSION self.disputesById[disputeId].disputeUintVars[keccak256(bytes)(minExecutionDate)] = now + 172800 * dispRounds
 In TellorStake.getTopRequestIDs, it can be over/underflowed. check your logic: EXPRESSION _requestIds[i] = self.currentMiners[4 - i].value
 In TellorDispute.vote, it can be over/underflowed. check your logic: EXPRESSION disp.disputeUintVars[keccak256(bytes)(numberOfVotes)] += 1
 In TellorTransfer.updateBalanceAtNow, it can be over/underflowed. check your logic: IF checkpoints.length == 0 || checkpoints[checkpoints.length - 1].fromBlock != block.number
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION _payReward(self,timeDiff,miners)
 In TellorLibrary.submitMiningSolution, it can be over/underflowed. check your logic: EXPRESSION _submitMiningSolution(self,_nonce,_requestId,_value)
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(allowedToTrade(self,_from,_amount),Should have sufficient balance to trade)
 In TellorDispute.proposeFork, it can be over/underflowed. check your logic: EXPRESSION self.uintVars[keccak256(bytes)(disputeCount)] ++
 In TellorTransfer.balanceOfAt, it can be over/underflowed. check your logic: EXPRESSION max = mid - 1
 In TellorLibrary._verifyNonce, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(uint256(sha256(bytes)(abi.encodePacked(ripemd160(bytes)(abi.encodePacked(keccak256(bytes)(abi.encodePacked(self.currentChallenge,msg.sender,_nonce))))))) % self.uintVars[difficulty] == 0 || (now - (now % 60)) - self.uintVars[timeOfLastNewValue] >= 900,Incorrect nonce for current challenge)
 In TellorTransfer.doTransfer, it can be over/underflowed. check your logic: NEW VARIABLE previousBalance = balanceOf(self,_from)
 In TellorLibrary.newBlock, it can be over/underflowed. check your logic: EXPRESSION j --
 In Utilities.getMin, it can be over/underflowed. check your logic: EXPRESSION i --
 In TellorDispute.unlockDisputeFee, it can be over/underflowed. check your logic: EXPRESSION require(bool,string)(now - last.disputeUintVars[keccak256(bytes)(tallyDate)] > 86400,Time for voting haven't elapsed)
 In TellorLibrary._payReward, it can be over/underflowed. check your logic: NEW VARIABLE reward = _timeDiff * _currReward / 300
 In Utilities.getMax5, it can be over/underflowed. check your logic: EXPRESSION j_scope_0 ++
 
line_number: 1577

Filename: 0xfacd9086c6647c589e6c39dddfecf9cea40d92aa_integerOverflow.sol
Output: Detecting specific vulnerabilities
Not supported file type
line_number: 74
line_number: 78
line_number: 89
line_number: 93

Filename: 0xfb594b9a0cacd9a4e4c506b4d318f7a7aa1cadc9_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In pCOMPVault.reward, it can be over/underflowed. check your logic: EXPRESSION i ++
 In pCOMPVault.availableWithdraw, it can be over/underflowed. check your logic: EXPRESSION -- i
 In ERC20.transferFrom, it can be over/underflowed. check your logic: EXPRESSION _transfer(sender,recipient,amount)
 In pCOMPVault.deposit, it can be over/underflowed. check your logic: EXPRESSION i ++
 In SafeMath.add, it can be over/underflowed. check your logic: NEW VARIABLE c = a + b
 In SafeMath.sub, it can be over/underflowed. check your logic: NEW VARIABLE c = a - b
 In pCOMPVault.reward, it can be over/underflowed. check your logic: EXPRESSION _rewardCount ++
 In SafeMath.mul, it can be over/underflowed. check your logic: NEW VARIABLE c = a * b
 In pCOMPVault.withdraw, it can be over/underflowed. check your logic: NEW VARIABLE availableWithdrawAmount = availableWithdraw(msg.sender)
 In pCOMPVault.availableWithdraw, it can be over/underflowed. check your logic: NEW VARIABLE i = _rewardCount - 1
 In pCOMPVault.depositAll, it can be over/underflowed. check your logic: EXPRESSION deposit(token.balanceOf(msg.sender))
 In pCOMPVault.withdrawAll, it can be over/underflowed. check your logic: EXPRESSION withdraw(rewardBalances[msg.sender])
 In ERC20._burnFrom, it can be over/underflowed. check your logic: EXPRESSION _burn(account,amount)
 In ERC20.transfer, it can be over/underflowed. check your logic: EXPRESSION _transfer(_msgSender(),recipient,amount)
 In pCOMPVault.deposit, it can be over/underflowed. check your logic: EXPRESSION addressIndices.push(msg.sender)
 In SafeMath.sub, it can be over/underflowed. check your logic: RETURN sub(a,b,SafeMath: subtraction overflow)
 
line_number: 314

Filename: 0xfcb7a9da74be3606e398acff8a87e9dc519ab8fa_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: over-underflow
impact: Low
confidence: Low
description
In BasicToken.constructor, it can be over/underflowed. check your logic: EXPRESSION total = _total * 10 ** uint256(decimals)
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 
line_number: 105
line_number: 107
line_number: 120
line_number: 122
line_number: 124

Filename: 0xff759254e578bc7f725428cecb612a502e604f42_integerOverflow.sol
Output: Detecting specific vulnerabilities
check: digits-suffix
impact: Informational
confidence: Medium
description
TokenERC20.constructor() (0xff759254e578bc7f725428cecb612a502e604f42_integerOverflow.sol#79-86) uses literals with too many digits: 12 recommended suffix: szabo
	- _totalSupply = 444 ** 12 * 10 ** uint256(decimals) (0xff759254e578bc7f725428cecb612a502e604f42_integerOverflow.sol#83)
 check: over-underflow
impact: Low
confidence: Low
description
In TokenERC20.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 444 ** 12 * 10 ** uint256(decimals)
 In BATG.tokenSale, it can be over/underflowed. check your logic: EXPRESSION _tkns = sChunk * _price
 In BATG.tokenSale, it can be over/underflowed. check your logic: EXPRESSION sTot ++
 In SafeMath.mul, it can be over/underflowed. check your logic: EXPRESSION c = a * b
 In BATG.constructor, it can be over/underflowed. check your logic: EXPRESSION _totalSupply = 444 ** 12 * 10 ** uint256(decimals)
 In SafeMath.sub, it can be over/underflowed. check your logic: EXPRESSION c = a - b
 In SafeMath.add, it can be over/underflowed. check your logic: EXPRESSION c = a + b
 In BATG.getAirdrop, it can be over/underflowed. check your logic: EXPRESSION aTot ++
 
line_number: 95
line_number: 97
line_number: 108
line_number: 110
line_number: 112

